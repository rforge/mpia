"fnessays";"content"
"data1_00_005.txt";"private String nachname, Bzw. private boolean angemeldet"
"data1_00_007.txt";"Dient dazu, dass Variablen und Methoden nur innerhalb der Klasse in der sie definiert wurden aufgerufen werden können. Befehl: private"
"data1_00_009.txt";"Private: nur innerhalb der kann auf die Variablen zugegriffen werden Public: auch von außerhalb der Klasse kann auf die Variablen zugegriffen werden"
"data1_00_014.txt";"mit private wird ausgesagt, dass andere Klassen nicht mehr auf diesen String bzw. boolean zugreifen können"
"data1_00_021.txt";"da die klasse student eine ""Private"" Klasse ist kann man sie nur innerhalb der Klasse aufrufen, und ist damit für anderen klassen sozusagen ""unsichtbar"" die ""Nachname"" ist private und für andere Klassen unsichtbar die ""angemeldet"" ist private und booleen    ob ein Student angemeldet ist oder nicht kann man nur dann sehen wenn man den Zugriff auf keine Klasse hat  "
"data1_00_027.txt";"Durch die Deklarierung der Variablen ""nachname"" + ""angemeldet"" ist der Zugriff eingeschränkt. Auf diese Variablen kann nur aus der Klasse zugegriffen werden in der die Variablen erstellt worden sind."
"data1_00_029.txt";"private string nachname; erlaubt ein Eingriff nur im gleichen Klasse private boolean angemeldet; im gleichen Klasse zugriff möglich public void print(); alle andere Klassen können auf diese Methode aufgreifen (keine beschränkte) verschiedene Package, vorsehen Klasse string vorname nur im gleichen Package"
"data1_00_035.txt";"Wenn ich die Methode ist angemeldet () und getName () mit private definiere können diese von innerhalb dieser klasse angesprochen werden und sind damit nach aussen nicht sichtbar. Wenn ich nicht will, daß man meinem Code zu leicht nachvollziehen kann verstecke ich Teile davon."
"data1_00_038.txt";"Durch private kann nur auf Variable und Methoden dieser Klasse von innerhalb eben dieser zugegriffen werden. Eine andere Klasse kann nicht auf die Variablen Nachname und angemeldet zugreifen."
"data1_00_045.txt";"Die Instanz der Klasse wird hinter der Methode versteckt, d.h. es kann nur mittels der Methode auf die Instanzen zurückgegriffen werden, aufgerufen werden. z.B. Student Josef: new Student () 	josef.matrNr=0050863"
"data1_00_055.txt";"class test 	private void method {}   Diese Methode ist durch das Schlüsselwort privat nur in der Klasse test sichtbar jedoch kann man über eine Methode darauf zugreifen."
"data1_00_068.txt";"Information Hiding ist notwendig um auf Methoden ""Eigenschaften zugreifen zu können, sie jedoch verändern zu können. d.h. man versteht etwas in einer Klasse."
"data1_00_073.txt";"Information Hiding bewirkt das verstecken von Information, d.h. die Variablen nachname und angemeldet können nach ihrer Zuweisung nicht mehr geändert werden."
"data1_00_074.txt";"I.H. meint das versteckte Übergeben von Informationen, die man nur bekommt, wenn man bestimmte Parameter kennt. Das soll verhindern, dass immer jeder auf alle Infos zugreifen und sie einsetzen kann."
"data1_00_081.txt";"durch deklarierte Methoden können nur durch get bzw set aufgerufen werden. private verhindert das Methoden in anderen Klassen benutzt werden"
"data1_00_098.txt";"Schützen Methoden gegen Zugriff von Aussen. Dadurch wird verhindert dass durch die anderen Zugriffe der Inhalt geändert werden kann"
"data1_00_104.txt";"Es müssen nicht alle Daten bei einer Implementierung neu geschrieben werden. Um das Programm nicht mit überflüssigen Infos zu überhäufen verbirgt man die Daten, die dann durch einen Code (getNachname) aufgerufen werden können."
"data1_05_010.txt";"Durch diese kann man Nachname und angemeldet nicht mehr sehen"
"data1_05_016.txt";"verstecken der Implementierung der Klasse hinter einer Methode, ich habe Zugriff nur über Methoden class Student{} string name=new string string semester=new string { this.name=name;"
"data1_05_023.txt";"""Nachname"" und ""Angemeldet"" sind als ""Private"" deklariert. d.h. sie können nur aus der selben Klasse gesehen werden. Package: Wenn als Package deklariert, dann ist es möglich sie aus der Klasse, den abgeleiteten Klassen und aus dem Package zu verwenden. Protected: Können nur aus der Klasse und aus abgeleiteten Klassen verwendet werden. Public: können von sämtlichen Klassen verwendet werden"
"data1_05_062.txt";"Durch das Wort private kann nicht mehr direkt auf eine Klasse zugegriffen werden., sondern nur über den Aufruf von den Methoden. Nachname u. angemeldet wurden hier als private definiert. Haben den gleichen Namen u. die gleichen Vornamen und befinden an unterschiedlich Orten."
"data1_05_086.txt";"Beim Information Hiding kann man Variablen und Operationen verstecken. Der Vorteil ist aber dass man die versteckten Variablen trotzdem benutzen und verändern kann und die versteckten Bezeichnungen und Variablen werden nicht verändert. Aus dem obigen Beispiel erkennt man, dass man auf die Variablen nachname und angemeldet nicht verändern kann außer die Werte."
"data1_05_105.txt";"Mit der Hilfe von private und protected kann den Zugriff zur Information beschränkt."
"data1_10_015.txt";"Mittels Deklaration als private kann verhindert werden, dass diese Klassen von außerhalb aufgerufen werden können Die beiden Variablen nachname und angemeldet sind dadurch von Zugriff außerhalb der Klasse geschützt."
"data1_10_018.txt";"Information hiding bedeutet, daß der Inhalt nicht für jeden sichtbar ist. In den Fall bedeutet ""private"", daß diese Variablen und ihre werte nur in dieser Klasse sichtbar und zugreiffbar sind."
"data1_10_022.txt";"Information hiding dient dazu, daß man bestimmten Information ""verstecken"" kann und damit nicht allen Klassen zugängig macht."
"data1_10_032.txt";"die Klasse wird hinter der Methode versteckt mit der get, set Methode sind immer public und die Klasse privat"
"data1_10_036.txt";"Information Hiding versteckt die Klasse hinter der Methode.  Es wird mit ""private"" deklariert (Klassen Name) Die Methode wird durch ""public"" (veröffentlich) weil jede Klasse an die Methode noch zusätzlich ""get x"" und ""set x"" haben damit es überhaupt funktioniert Sonst kommt ein fehler raus Bei Information Hiding können wir die Variablen oder anders gesagt die Klasse durch die Methode aufrufen"
"data1_10_040.txt";"private nachname und angemeldet diese 2 Instanzvaraiblen können nur in der Klasse Student gelesen werden. kein Zugriff von außen Information Hiding nachname und vorname und angemeldet sollen nicht in Zusammenhang gebracht werden können außerhalb dieses Klasse"
"data1_10_041.txt";"In Instanz-Variablen in der Klasse wird vor Zugriff von klassen von außerhalb geschützt Data-Kapselung"
"data1_10_049.txt";"Information Hiding heißt, dass auf Grund der ""Data Encapsulation"" auf die Variablenwerte von Objekten (diese sind ja ""private"" definiert) nur über Anruf von Methoden zugriffen werden kann."
"data1_10_050.txt";"Mittels Information hiding wird der Zugriff auf bestimmte Variablen / Methoden beschränkt.  Es gibt verschiedene Stufen (public, package, private, protected). In obigem Bsp. kann aufgrund von ""private"" auf die Variable nachname und angemeldet nur aus der Klasse oder einem Package zugegriffen werden, nicht aber von Subklassen."
"data1_10_051.txt";"die beiden variablen  nachname und angemeldet sind durch den Zusatz private für andere Klassen nicht mehr zugänglich. Sie können nur mehr in der Klasse Student verwendet werden."
"data1_10_058.txt";"Private string nachname; Private boolean angemeldet   Zugriffbarkeit  Private verhindert den Zugriff dieser Variablen von außen. Diese Variablen kann nur in Klasse ""Student"" nutzen und aufrufen sonst die anderen Klassen können diese nicht aufrufen. Protect die Informationen in einer Klasse von außen Zugriff."
"data1_10_060.txt";"durch die Deklarierung private können die Variablen nur in der Klasse in der sie erzeugt wurden, verwendet werden. Auch Subklassen haben keinen Zugriff auf die als private deklarierten Klassen."
"data1_10_067.txt";"Auf die Variablen von einer Instanz der Klasse Student kann von außen nicht direkt zugegriffen werden. es können nur die Methoden aufgerufen werden um die Variablen anzusehen."
"data1_10_071.txt";"die Variable nachname ist als private definiert, kann also von außerhalb der klassendefinition nicht geändert werden."
"data1_10_083.txt";"Bei sensiblen Daten kann man durch I.H nur über Methoden und nicht direkt auf die Variablen zugreifen. Des weiteren können damit Fehler vermieden werden Im Bsp. wird abgefragt ob eine Instanzvariable angemeldet wahr oder falsch ist Es kann allerdings aus anderen Kl. (= ) nicht auf diese zugegriffen werden. Abhilfe über Methoden, die nur den Wert zurückgeben "
"data1_10_089.txt";"Dient zur Sicherung von Daten nach aussen. private ist eine Alterbeit den Zugriffs kann der alle es besagt, dass auf angemeldet und nachname in der Klasse Student zugegriffen werden kann. public... es kann auch von aussen (z.B. anderen Klassen) auf die Methode zugegriffen werden. Standard einstellung: package"
"data1_15_008.txt";"Information Hiding ist ein Begriff für das verstecken der Variablen einer Klasse (private boolean angemeldet) hinter der Methode Das heißt auf die Variablen kann nur über die Methoden zugegriffen werden"
"data1_15_011.txt";"Mit d. Schlüsselwörtern private kann nur innerhalb d. eigenen Klasse auf d. Variablen zugegriffen werden. Außerhalb davon sind sie nicht erreichbar."
"data1_15_025.txt";"Keine direkter zugriff auf die variable sondern Methoden Aufruf private string nachname private boolean angemeldet"
"data1_15_034.txt";"durch ""private"" ist der Zugriff auf Objekte und Variablen beschränkt, es darf nur aus der selben Klasse zugegriffen werden dadurch ist die Information vor Zugriff und veränderung von ausserhalb geschützt"
"data1_15_039.txt";"Information Hiding dient dazu, gewisse hier z.B. die Variable ""String nachname"" zu verstecken, d.h. sie nicht von jeder beliebigen Klasse (oder Program) ausführbar zu machen. Das wird hier durch die Eigenschaft ""privat"" gekennzeichnet."
"data1_15_048.txt";"Information hiding wird im Java benutzt, um den zugriff auf klassen Methoden oder Variablen zu regeln. Das prinzip wird auch Datenkapselung genannt. Es gibt vier mögliche Einstellungen: public: der Zugriff aus allen Klassen möglich private: nur die Klasse, in der das als private erstellte Objekt deklariert wurde und daraus abgeleitete Klassen + Klassen des gleichen Packages können darauf zugreifen protected: nur die Klasse, in der es erstellt wurde + Klassen des gleichen Packages können darauf zugreifen wird kein Wert gesetzt wird automatisch der Standardwert package verwendet"
"data1_15_084.txt";"die Variablen nachname und angemeldet sind hidden Variablen; d.h. nur die Mitglied Funktion der Klasse können den Zugriff haben; Ausserhalb der Klasse kann man die Werte lesen noch ändern"
"data1_15_085.txt";"Information Hiding bedeutet, dass in einer Klasse solche Variablen deklariert sind, die nur durch eine Methode aufrufbar sind. Wie zum Beispiel angemeldet. Variable Angemeldet kann mit der Methode istAngemeldet angerufen werden."
"data1_15_094.txt";"Information Hiding verfolgt das Konzept der Sicherheit vor unauthorizierter Manipulation des Datenmaterials und ermöglicht eine nachfolgende einfache Änderung des Programmes, da nicht der gesamte Quellcode überarbeitet werden muß sondern die einzelen Methoden, die geändert werden sollen! In diesen Beispiel zum Beispiel könnte man in Get Nachname () noch weitere features einbauen (Bsp. Get Nachname ruft eine Methode auf die ein Logfile mit den Daten des Abfragers speist)"
"data1_20_002.txt";"Dient dem Sicherheitaspekt die Werte der Variablen nachname und angemeldet können nur mit Hilfe von Methodenaufrufen ermittelt werden; ansonsten sind diese Variable nicht direkt aufrufbar/ versteckt (vor allem v für Klassen, die der Definition von private nicht entsprechen)."
"data1_20_020.txt";"die mit dem Schlüsselwort private definierten Werte können nur innerhalb der Klasse ausgelesen werden. um der Wert der variablen auszulesen wird die Methode getnachname generiert. Von außen kann der Wert der mit private definierten variablen nicht ausgelesen werden. somit kann der wert sicher vorborgen werden."
"data1_20_026.txt";"wir können etwas verstecken, aber nicht alles.  Wir brauchen diese Funktion zum Schutz der Daten. Wir haben als private nachname deklariert und das bedeutet das nachname kann nur in Klasse Student verwendet werden (in der Klasse wo sie deklariert ist), nicht in abgeleiteten Klassen."
"data1_20_033.txt";"Die Implementierung der Daten kann verändert werden, ohne dass Programmcode außerhalb der Klasse geändert werden muß. Der Zugriff auf die verschiedenen Variablen kann eingeschränkt werden. Dies verhindert sowohl Datenmanipulation, als auch irrtümliche Veränderung oder Abfrage der Daten.  Außerdem können damit die Programmierfehler eingeschränkt werden."
"data1_20_044.txt";"Als Information Hiding bezeichnet man das Verstecken von Informationen einer Klasse. Das heißt daß es nicht möglich ist direkt auf Variablen zuzugereifen, sondern nur über den Anruf einer entsprechenden Methode. Dieses Konzept der OOP wird auch ""Data Encapsulation"" oder Datenkapselung genannt."
"data1_20_047.txt";"mit ""private"" deklariert man kann nur über die Klasse die sie enthält nur darauf zugereifen setzen einer Variable mit set variablenName zurückgeben mit get variablenName"
"data1_20_054.txt";"Information Hiding dient dazu einige / alle private deklarierten Variablen und Methoden zu ""verstecken"" bzw. den Zugriff auf sie einzuschränken. z.B. private String nachname und private boolean angemeldet können nur innerhalb der Klasse Student gesetzt/ geändert werden."
"data1_20_057.txt";"Durch Information Hiding wird der Zugriff auf bestimmte Variablen eingeschränkt, und ist nur noch über die implementierten 		(von außerhalb der Klasse oder des Packages) Methoden möglich In unserem Fall verhindert die Deklaration der Variablen als private (eingeschränkte Sichtbar- und Nutzbarkeit), das auf die Variablen von außerhalb der klasse zugegriffen wird."
"data1_20_063.txt";"Die in einer Klasse deklarierten Variablen können durch ""Hiding"" ""versteckt"" werden, das bedeutet, ihre Werte können nicht geändert werden. Zugriff eingeschränkt. Das wird erreicht durch das Erklären der Variable als ""private"". Mit getMethode bzw setMethode kann auf Werte zugegriffen werden, u. diese können verändert werden"
"data1_20_075.txt";"wenn Infos nicht von überall her (aus allen Klassen) aufgerufen werden sollen/können; (zB bei Code Bsp) mit Nachname können auf Instanzvariablen und Methoden um vor die Werte am zugegriffen werden, an der sie implementiert werden sind. Das gilt für private String nachname; private boolean angemeldet;"
"data1_20_079.txt";"Information Hiding bedeutet den Zugriff auf Instanzvariablen zu erschweren, in dem man sie ""private"" deklariert. Dadurch müssen eigene Methoden geschrieben werden, mit denen auf die Variable zugegriffen werden kann. In obigen Bsp.: private String nachname; Dadurch kann von außerhalb der Klasse nur durch getVorname() zugegriffen werden."
"data1_20_080.txt";"Betrifft die Sichtbarkeit bzw. den Zugriff auf beschränkte Methoden oder Variablen. Private: Variablen und Methoden lassen sich nur von der Klasse, in der sie erzeugt werden, verwenden bzw. aufrufen. Hier: private String nachname private boolean angemeldet Kein Zugriff von außen möglich."
"data1_20_091.txt";"Information Hiding: Variable sind nur über Methoden zugänglich, werden als private deklariert, können nicht geändert werden (nachname, angemeldet)"
"data1_20_092.txt";"Eine Variable (hier: ""nachname"" und ""angemeldet"") wird als private deklariert damit man nicht direkt auf sie zugreifen kann sondern über Methodenaufruf (hier: ""istAngemeldet"" und ""getNachname"")"
"data1_20_096.txt";"Man hat die Variablen nachname und angemeldet private deklariert. Damit können die Werte und der Zugriff nur über Methoden ausgelesen werden. Zugriffsbeschränkung weil man aus anderen Klassen nicht auf diese Variablen zugreifen kann."
"data1_20_101.txt";"private String nachname; Von außen kann nicht auf die Variablen zugegriffen werden! Methoden müssen public deklariert werden. public void print() Nur innerhalb der eigenen Klasse gültig."
"data1_25_052.txt";"Information hiding wird mit dem Schlüsselwort private eingeleitet. Durch das Deklarieren der Variablen als ""private"" wird der Zugriff auf diese Variablen von aussen unmöglich. Dies ermöglicht (neben der erläuterten Zugriffssteuerung) auch eine leichtere Änderung der Variable ohne dass der äußere programcode geändert werden muß. Außerdem wird die Datenmnipulation oder versehentliche Änderung der Daten verhindert."
"data1_25_061.txt";"Die Instanzvariablen sind private deklariert und es kann nur durch die Methode print(), die public zugegriffen werden. erhöht Sicherheit."
"data1_25_078.txt";"private String nachname; private boolean angemeldet; ""Information Hiding"" versteckt Daten durch privat Um Daten anzugreifen, benötigt man get und get Methoden"
"data1_25_082.txt";"Durch das Wort ""private"" vor der Deklaration der Variablen sind die sichtbarkeit von Vorname und angemeldet auf die eigene Klasse beschränkt. Zugriff von außerhalb der Klasse ist nur durch den Rückgabewert einer Methode (welche sich ja in der gleichen Klasse befindet) möglich."
"data1_30_001.txt";"Information Hiding wird mit dem Schlüsselwort private eingeleitet und dann kann man nur noch mit get oder set Methoden auf die Variablen zugreifen. Das verhindert Datenmanipulation und ein Überschreiben der private Variablen oder Methoden. Auch unerlaubte Datenzugriffe werden erschwert. Im Gegenatz dazu die public Variablen, auf die kann jede Klasse und Methode zugreifen. Gut in diesem Beispiel ersichtlich, da beide verwendet werden."
"data1_30_013.txt";"Information hiding: mit Keyword private private bewirkt, daß auf die Variablen die private deklariert sind nur innerhalb der Klasse zugegriffen werden kann. Funktioniert auch mit Methoden  durch Methoden wie z.B. getName die public sind und den namen enthalten kann auch von einer anderen Klasse auf den mann zugegriffen werden"
"data1_30_017.txt";"Durch diese Deklaration der Variablen nachname kann der Variablen nur innerhalb der Klasse ein Wert zugewiesen werden. Sinn: Verhindern von unzulässigen Beeinflussungen versehentliches Löschen nicht möglich. Der Wert kann eben nur mit Hilfe von SET und GET MEthoden geändert bzw. aufgerufen werden. Dann auch von Außerhalb. (sofern die Methode public) Sicherheitsmaßnahme"
"data1_30_028.txt";"private string nachname private boolean angemeldet wenn wir benutzen ""privat"", einschränken wir die Zugriff auf fremden classe und verhindern wir irrtümliche Veränderungen. Es gibt noch set und get (public) Methoden zur Einschränkungen"
"data1_30_030.txt";"Information Hiding ist das ""verstecken"" von Variablen, so dass sie nur über die Methoden den Klasse aufrufbar sind! Sowohl die variable ""angemeldet"" als auch ""nachname"" sind als private deklariert und können somit vom außerhalb der Klasse nur über die Methoden initialisiert oder aufgerufen (abgefragt) und geändert werden! Diese Methoden werden meist als public definiert (je nachdem von wo aus sie aufgerufen werden sollen!)"
"data1_30_031.txt";"Information Hiding wird auch Data Encapsulation genannt. Es werden die Variablen private deklariert. Dadurch können die Variablen nur in der Klasse selbst aufgerufen werden, es kann nicht direkt auf sie zugriffen werden, sondern über die Methoden get und set. Sie dient dazu, um Veränderungen aus anderen Klassen zu vermeiden."
"data1_30_037.txt";"Durch Informationen Hiding wird die Sicherheit und den Zugriff auf die Variable beschränkt. Man kann auf die variable durch eine public deklarierte Methode zugreifen."
"data1_30_042.txt";"information Hiding: ist verstecken der Implementierung einer Klasse hinter der Methoden die auf ihre Klassendaten ausgeführt werden. z.B. private, public, protected, package In der oberigen Bsp. ist nachname und angemeldet PRIVAT deklariert d.h. auf die 2 Variablen kan nur aus dieser Klasse zugegrifen werden. Die Methode PRINT ist PUBLIC deklariert d.h. auf die Methode kann jeder zugreifen."
"data1_30_046.txt";"Wenn eine variable hidden, bzw. private ist, kann sie außerhalb der Klasse nicht abgerufen werden. Es muss zuerst mit Hilfe von Methoden z.B. get public gemacht werden um dann weiter verarbeitet werden zu können."
"data1_30_053.txt";"Die Informationen einer Klasse sollen so gut wie möglich geschützt werden um Datenmanipulation und ungewünschte änderungen zu vermeiden. In der Klasse Student sind die Var, nachname u. angemeldet private deklariert. Dies bedeutet, dass nur aus der klasse Student auf diese Variablen zugriffen werden kann. Die Variable Vorname  es wird package angenommen Nur aus der eigenen Klasse und den package 			(Student)"
"data1_30_059.txt";"Der String Nachname + boolean angemeldet sind als private definiert, somit für andere Klassen nicht sichtbar. die Methoden istAngemeldet und getNachname habe ich public definiert. Sie sind somit in der Klasse Student, und können, da sie nach außen hier sichtbar sind. von anderen Klassen aufgerufen werden, und damit den Wert der als private deklarierten Variablen zurückliefern."
"data1_30_066.txt";"auf die Instanzvariablen nachname und angemeldet kann man aus der Klasse Student zugriffen werden, sie können also nur über die Methoden istAngemeldet() und getNachname() angesprochen werden. dadurch kann keiner unzulässig, (oder ungewünschte) ändern, den Variablen aus einen fremde Klasse verhindert werden. Information Hiding verwendet durch die Deklaration von Variable als ""private""."
"data1_30_069.txt";"die Instanzvariable nachname und angemeldet ist nur innerhalb von Klasse abrufbar. D.H. um diese Information abrufen zu können müssen extra Methoden definiert werden (wie vorigen beispiel) erst durch abrufen von jeweiligen Methoden (für nachname: getNachname(), und für angemeldet: istAngemeldet() werden die informationen durch jeweiligen Methoden abrufen. Information Hiding wird benutzt, um bestimmte Informationen außerhalb Klassen (vor fremden Klasse) nicht direkt abrufen / manipuliert werden können. (für Sicherheit oder leichte erweiterbarkeit/modizifierbar d. Klassen)"
"data1_30_070.txt";"class Pruefung { String Vorlesung; String datum; private int note; public void setNote(int note) { } this.note = note; public int getNote() { return note; } } class Profesor { public static main(String[] args) { Pruefung karl = neu Pruefung(); karl.vorlesung = ""Java""; karl.datum = ""2004-04-30""; karl.note = 1; karl.setNote(1); } } class intfalsch das geht. Professor hat Zugriff nur zu Methoden set/getName, aber keinen direkten Zugriff zu Instanzvariable Note."
"data1_30_072.txt";"Datenkapselung (data encapsulation) d.h. man kann nicht direkt auf die Variablen zugreifen, sondern nur über Methodenaufruf. Vorteile: Vermeiden von Programmfehlern und Datenmanipulation Implementierung der Daten, ohne das der Programmcode d. Klasse geändert werden muß"
"data1_30_087.txt";"Durch das Schreiben von private vor die Instanzvariablen wird ein direktes Zugreifen verhindert. Der Zugriff erfolgt über die Methoden istAngemeldet() und getNachname()"
"data1_30_090.txt";"Information Hiding ist das verstecken der Implementierung der Klasse hinter der Methode. Also beim direkten Zugriff auf die Variablen muß via Methodenaufruf.  Bsp. die Variablen nachname und angemeldet werden mit ""private"" deklariert. Also kann man via Methodenaufruf auf die Variablen zugegriffen werden."
"data1_30_093.txt";"Die beiden Variablen ""nachname"" und ""angemeldet"" sind private und somit nur aus der eigenen Klasse ansprech- und änderbar. Damit verhindert man die Manipulation von außen Um dennoch auf die Werte dieser Variablen von aussen zugreifen zu können, werden die zwei gefragten Methoden implementiert. Somit lässt sich durch Information hiding der Zugriff steuern."
"data1_30_095.txt";"Variablen werden als private deklariert können nur über die Methoden aufgerufen werden! Vorteile: ""beschränkt"" Datenmanipulation Programmierfehler werden beschränkt"
"data1_30_097.txt";"Durch Information Hiding wird der Zugriff auf Variablen eingeschränkt. Es verhindert somit einen (ungewollte) direkten Zugriff auf die Variablen. Es kann nur indirekt Methoden auf die Variablen zugegriffen werden. Die Variablen müssen als private deklariert sein, Beispiel: private String nachname; private boolean angemeldet;"
"data1_30_099.txt";"nachname und zugemeldet sind nur innerhalb der class verwendbar (und in den Methoden), weil private mit den Methoden get kann ich indirekt zugreifen, da sie package access haben und von public (alle classes haben darauf Zugriff) Methode print aufgerufen werden. Nur der ""vorname"" wäre auch mit package access (man fragt sich, weshalb)"
"data1_30_102.txt";"Es kann nicht direkt auf die Variablen nachname und angemeldet zugegriffen werden, da private definiert. Schützt vor unerlaubtem Zugriff Schützt vor Fehlern beim programmieren Damit die genannten Variablen geschützt werden können, muss der Zugriff mit einer eigenen Methode erfolgen. getNachname ist Angemeldet"
"data1_30_103.txt";"Data Encapsulation Zugriff auf die Daten einer Klasse können nur durch Befehle erfolgen. Es besteht nicht die Mõglichkeit direkt auf die Variablen einer Klasse zuzugreifen. deklaration mit dem Schlüsselwort ""private""."
"data1_30_106.txt";"Mittels Information Hiding werden Methoden und Eigenschaften einer Klasse nach außen ""unsichtbar"" gemacht. Beispiel: private String nachname; Durch ""private"" kann auf nachname nur innerhalb der Klasse die Eigenschaft nachname vesucht werden. Von außen ist die Eigenschaft unsichtbar und kann nicht gelesen oder geschrieben werden. Diese könnte nur über ev. Methoden (z.B. setNachname) durchgeführt werden. Dadurch wird Übersichtlichkeit erreicht. Weiters können damit unvorhergesehene Abläufe durch unbeabsichtigtes Ändern der Eigenschaft von außen verhindert werden."
"data1_30_107.txt";"Variable nachname ist mit ""Private"" deklariert. Kann nur in der Klasse Student verwendet und verändert werden. Sinn: Außerhalb der Klasse nicht sichtbar. veränderbar. Schutz von Außen Zugriff über get und set Befehle."
"data1_35_003.txt";"Information hiding bedeutet das verstecken von Informationen hinter den methoden. die Variablen werden als ""private"" definiert zB.: private String nachname die Methode kann dann diese Variablen mit ""get"" oder ""set"" ausbrechen zB.: public Student getNachname (...){...} diese Methode muss dann als ""pubilc"" definiert werden"
"data1_35_043.txt";"Information Hiding wird in Java durch Deklaration der klassen variablen mit privat erreicht. Das bedeutet, dass nur Methoden innerhalb der klasse auf diese Variablen zugreifen können. Die Methoden fungieren als Schnittstellen. Damit Verhindert man Manipulation oder z.B. versehentliches Löschen der Variablen."
"data1_40_004.txt";"verstecken der Variablen hinter der Implementierung der Methoden Variablen müssen private deklariert sein. die Methoden public es kann nur über die Methoden auf die Variablen zugegriffen werden Methode getNachname() gibt string machname aus schützt vor Datenmanipulation, vor unerwünschtem Zugriff, unerwünschter Veränderung der Variablen, ""versehentlichem"" verändern der Variablen  zugriff mit get...(); setzen mit set..();"
"data1_40_056.txt";"Auch Data Encapsulation genannt Man verhindert hier den direkten zugriff auf Variablen im Beispiel realisiert durch zB private (essenzielles Keyword). Auf Instanzvarablen kann nur mittels Methoden zugegriff. werden, die public deklariert sein müssen, vorteile: gewährleistet zB keine Datenmanipulation,..."
"data1_40_064.txt";"kein direkter Zugriff auf Variablen, nur via Methodenaufruf istangemeldet() und getNachname(); deklaration der Variablen als private ""Data Encapsulation"" genannt Damit kann man den Zugriff einschränken. Die Methoden können public sein"
"data1_40_077.txt";"Information Hiding verhindert, das aus anderen Klassen die Instanzvariablen der Klasse direkt referenziert werden können. In diesem Beispiel werden die Instanzvariablen nachname und angemeldet der Klasse Student als private deklariert. dh sie können nur innerhalb der eigenen Klasse geändert (referenziert) werden. Die Variable Vorname könnte auch außerhalb der eigenen Klasse referenziert werden ( Standardeinstellung. package). die Methoden istAngemeldet und getNachname werden als public deklariert. Dh sie können von der eigenen Klasse aber nicht von allen anderen Klassen aufgerufen werden. Diese beiden Methoden geben den Wert von angemeldet bzw. nachname vom jeweiligen aufrufenden Objekt zurück. I.H. verhindert Datenmanipulation aber auch irrtümmliche Änderung der Daten. Außerdem ermöglicht es eine Zugriffskontrolle."
"data1_40_088.txt";"Datenkapselung. Verstecken der Implementierung hinter den Methoden. kein Zugriff von außen möglich. Erreicht man in dem man Varieblen private deklariert. Zugriff nur über Methodenaufruf möglich. Dazu braucht man Methoden get und set die public definiert werden müssen. Über Methode get kommt man zu Wert d. Methode und set kann Wert verändern bzw. setzen."
"data1_40_100.txt";"""Information Hiding"" dient dazu die Sichtbarkeit und Zugriffsmöglichkeiten von Variablen zu beschränken. Hierzu werden innerhalb einer Klasse Variablen als ""private"" definiert (z.B.: private String nachname) und diese als Rückgaben einer mit ""public"" deklarierten Methode ausgegeben. Außerhalb der Klasse kann auf die Variable dadurch nur über die Methode zugegriffen werden."
"data1_40_108.txt";"Information Hiding ermöglicht es, den direkten Zugriff auf Variablen zu verhindern. bietet gewisse Sicherheit. Zum Beispiel: public class Pruefung { private int node; public void setNote(int note) { this.note = note; } public int getNote () { return note; } ermöglicht ""das Setzen"" d. Variable note auf einen best. Wert. note wird ausgelesen ... somit wird nie direkt auf note zugegriffen, sondern nur über d. Methoden getNote bzw setNote"
"data10_00_01.txt";"Implementierungsebene"
"data10_00_02.txt";"komponenten test system test Black box test white box test"
"data10_00_03.txt";"konzeptionelle ebene"
"data10_00_04.txt";"extern - test findet draußen statt intern - test findet drinnen statt gesamt - von allen und überall"
"data10_00_05.txt";"personengruppe stellt anforderungen beachten ist hierbei, daß auf bestimmte anforderungen geachtet wird: rechtliche rahmenbedingungen konkurrenzprodukte anforderungen der kunden kunde / benutzer test / qualitätssicherung"
"data10_05_06.txt";"anwendungsebene: letzte ebene, black box verfahren, kein vorwissen der internen struktur nötig einführungsebene: tests nahe am quellcode, wird als ganzes (-system) getestet entwicklungsebene: tests am qullcode, einzelne subsysteme werden getestet"
"data10_05_07.txt";"kompatibilitätstest: die einzelnen komponenten werden auf kompatibilität getestet integrationstest: einzelnen komponenten werden auf ihre integration in das gesamt modell getestet systemtest: test des gesamten systems"
"data10_05_08.txt";"white box verfahren: überprüfung der implementierung nahe am quellcode black box verfahren: erfüllt die software die spezifikation manuelle verfahren: überprüfung des quellcodes ohne ausführung des programmes"
"data10_05_09.txt";"white box test einige artikel des subsystems testen black box test einige subsysteme des systems testen conquest test ganzes system wie gesamtheit testen"
"data10_10_10.txt";"komponenten test: hier wird getestet ob die software-komponenten zusammenarbeiten integrationstest: hier wird getestet wie die einzelnen systeme zusammenarbeiten, sobald sie in das system integriert werden software test: hier wird software für sich getestet"
"data10_10_11.txt";"systemtest - test des quellcodes komponententest - code / kontext test integrationstest - test der spezifikation"
"data10_15_12.txt";"software test ist prozess, bei dem geprüft wird ob software bestimmten spezifikationen entspricht komplette fehlerfreiheit kann jedoch nicht nachgewiesen werden die diversen abstraktionsebenen der software-systeme bei denen getestet wird ist komponententest, integrationstest, systemtest testverfahren lassen sich in white box und black box unterteilen"
"data10_15_13.txt";"white box verfahren: es wird der quellcode überprüft auf richtigkeit black box verfahren: es wird überprüft ob das programm das tut, was es soll integrationstest: integration in anderen software-systemen wird überprüft"
"data10_15_14.txt";"komponententest - jede einzelne komponente wird getestet systemtest - das ganze software system wird getestet anforderungstest - das betrachtete software system wird getestet, ob es den zugrundeliegenden anforderungsspezifikation entspricht"
"data10_15_15.txt";"test auf source code ebene (jede routine wird mindestens ein mal durchlaufen) test der einzelnen interfaces (programm routinen werden einzelnen getestet) test auf systemebene (das fertig installierte system wird als ganzes auf der später verwendeten umgebung getestet)"
"data10_15_16.txt";"komponententest: nur einzelne komponenten werden getestet systemtest: gesamtsystem wird getestet mehrere komponenten werden zusammengefaßt"
"data10_20_17.txt";"komponententest: die einzelnen komponenten werden auf ihre funktion getestet und ob diese den anforderungen entsprechen integrationstest: hier wird das zusammenspiel der funktionen der komponenten getestet systemtest: das komplette system wird getestet, ob es den spezifikationen entspricht"
"data10_20_18.txt";"komponententest: überprüfe der einzelnen komponenten integrationstest: überprüfe das zusammenpassen der komponenten systemtest: teste das system aus anwendersicht"
"data10_20_19.txt";"integrationstest - integration ins system möglich oder wie bereits verlaufen systemtest - funktioniert die software im system? fehler? komponententest - erfüllt die jeweilige komponente des systems die jeweilige funktion?"
"data10_20_20.txt";"integrationstest: es wird getestet für ganze system, ob ein system komplex langjährig ist funktionstest: testet, ob ein subsystem funktioniert ist komponententest: jede komponente wird isoliert getestet"
"data10_20_21.txt";"modulebene - die einzelnen komponenten werden einzeln getestet systemebene - die kooperation der komponenten miteinander wird getestet kontextebene - die software wird so getestet, als daß in den einsatz wäre, also wie das die endbenutzer sehen"
"data10_25_22.txt";"komponententest: zusammenspiel der komponenten getestet systemtest: das system selbst getestet ob es anforderungen entspricht integrationstest: interaktion zwischen system und seiner umgebung testen"
"data10_25_23.txt";"system test: das komplettsystem wird mit dem altsystem getestet integritätstest: es werden die komponenten mit einander getestet komponententest: es werden die einzelnen komponenten unabhängig voneinander getestet"
"data10_25_24.txt";"komponententest: die komponenten der software werden jeweils einzeln auf ehler untersucht integrationstest: wie die einzelnen bausteine der software zusammen funktionieren systemtest: funktioniert die programmierte software in den verschiedenen vorhandenen systemen?"
"data10_25_25.txt";"systemebene: hier wird das komplette software system auf seine lauffähigkeit und funktion geprüft integrationseben: hier wird das zusammenspiel der verschiedenen komponenten auf funktionsfähigkeit überprüft komponenteneben: hier werden die einzelnen softwarekomponenten / -bausteine auf ihre funktionsfähigkeit überprüft"
"data10_25_26.txt";"systemtest - hier wird der ganze system getestet, einblack box test komponententest - die einzige komponenten werden allein getestet, meist auf der ebene von quellcoden verbindungentest - getestet werden die einzigen verbindungen zwischen komponenten, ein white box test und wie / ob die komponenten zusammen kommunizieren"
"data10_25_27.txt";"komponententest: einzelne komponenten werden getestet integrationstest: komponenten und umgebung auf integrität getestet systemtest: voll check aus der sicht des anwenders"
"data10_30_29.txt";"komponententest: einzelne komponenten werden getestet integrationstest: das zusammenspiel der verschiedenen komponenten wird ausgetestet systemtest: das gesamtprogramm wird im zielsystem (OS, rechner, andere programme) getestet"
"data10_30_30.txt";"komponententest - test jeder komponente, ganz nahe an der eigentlichen implementierung integrationstest - einzelne subsysteme werden getestet black box test oder systemtest - das system wird ohne kenntnis der internen struktur getestet (eventuell mit dokumentation)"
"data10_30_31.txt";"komponententest: die einzelnen verwendeten softwarekomponenten werden getrennt voneinander betrachtet und einzeln getestet systemtest: das gesamte softwaresystem wird betrachtet und auch das gesamte system zusammen getestet subsystemtest: einige softwarekomponenten werden zu subsystemen zusammengefasst und so getestet"
"data10_30_32.txt";"systemtest: hier wird geprüft ob das systm in seiner vorgesehenen umfebung lauffähig ist. (benutzer-sicht) integrationstest: hier wird geprüft ob das zusammenspiel der komponenten eines systems fehlerfrei läuft komponententest: hier wird jede einzelne system-komponente geprüft ob sie ihre anforderungen (funktionen) erfüllt"
"data10_30_33.txt";"komponententest implementierungstest systemtest beim komponententest werden die einzelnen komponenten überprüft, ob sie die vorgesehenen aufgaben erfüllen können. beim implementierungstest werden die komponenten nicht mehr einzeln überprüft, sondern miteinander, ob sie miteinander funktionieren. beim systemtest wird das ganze system getestet, ob es die vorgesehenen aufgaben erfüllen kann"
"data10_30_34.txt";"komponentensystemtest: hier werden die einzelnen komponenten eines systems auf ihre funktionalität geprüft. prüfung nach dem quellcode integrationstest: hierbei wird anschließend auf den komponententest geprüft ob die einzelnen komponenten in einer weise interagieren, sodaß sie ihre funktionen richtig zur verfügung stellen systemtest: hierbei wird aus der benutzersicht geprüft ob die dokumentation des systems den festgelegten anforderungen enspricht (black box verfahren)"
"data10_30_35.txt";"komponententest: nahe am quellcode, white box verfahren jede zeile der komponenten wird geprüft anweisungsüberdeckungstest: jede anweisung wird mindestens ein mal durchlaufen zweigüberdeckungstest: jede verzweichung wird mindestens ein mal durchlaufen pfadüberdeckungstest: jeder pfad soll ausgeführt werden integrationstest: einzelne komponenten beziehungsweise systemteile werden zusammen getestet, ob sie richtig interagieren systemtest: das gesamte system wird in vorgesehener systemumgebung aus benutzersicht getestet"
"data10_30_36.txt";"komponententest - die funktionalitäten der software-komponenten werden auf dieser abstraktionsebene getestet integrationstest - testätigkeiten, die das ziel befolgen, die interaktionen und zusammenhänge zwischen den software-komponenten zu testen und zu vergleichen, ob diese interaktionsbeziehungen der anforderungsspezifikation entsprechen systemtest - testverfahren, das das system als ganzes und die beziehungen des systems mit der software-umgebung (kontext) testet (höchste abstraktionsebene)"
"data10_30_38.txt";"komponententest: hier wird sehr nahe am quellcode gearbeitet, einzelne komponenten werden hier isoliert beobachtet und unter den testdaten getestet, ob sie die (ihre) funktionalitäten korrekt zur verfügung stellen integrationstest: hier schaut man sich gemeinsame komponenten an, wird gemeinsam getestet und schaut, ob jede komponenten auch ihre funktionalitäten korrekt zur verfügung stellt systemtest: ist immer black box verfahren, aus der sicht der enduser wird getestet, schaut ob die komponenten den spezifikationen entsprechen, ob funktionalitäten der enduser realisiert werden"
"data10_30_39.txt";"komponententest: einzelne komponenten werden für sich getestet. (testparameter für schnittstellen werden künstlich generiert - nicht von anderen komponenten) integrationstest: zusammenspiel von systemkomponenten wird getestet (einige / alle komponenten beteiligt) systemtest: das gesamtsystem aus endbenutzersicht wird getestet (typischer black box test)"
"data10_30_40.txt";"komponententest / modultest: die einzelnen komponenten werden hinsichtlich ihrer funktionalität isoliert betrachtet und mit fällen getestet integrationstest: die komponenten werden zu subsystemen integriert. die funktionalität dieser subsysteme wird getestet. es gibt bereits interaktionen. systemtest: das gesamte system wird unter möglichst realen bedingungen hinsichtlich der benutzeranforderungen getestet"
"data10_30_41.txt";"komponententest - jede einzelne komponente wird im quellcode untersucht und getestet interaktionstest - test, ob die komponenten in der weise miteinander interagieren, in der sie sollen systemtest - test aus der benutzersicht, ob das system den anforderungen (die vorher spezifiziert wurden) entspricht"
"data2_0_032.txt";"aus verschiedensten Bereichen bestimmte Gebiete auswählen zu können; der Kunde kann rasch sein gewünschtes Ziel erreichen, da eine große Auswahl bzw. Überblick über das Angebote bekommt; Auch für den Administrator von Vorteil, da er einen klaren Überblick hat -> leichte Betreuung möglich, einfache Änderungen möglich"
"data2_0_070.txt";"Ein elektronischer Katalog ist eine undynamische Struktur im WEB die hierarchisch aufgebaut ist und Informationen enthält und auflistet oder Verweise nach Informationsquellen enthält. Elektr. Katalog enthält hierarchisch aufgebaute Links, die dann zu den angebotenen Infos führen. Aus Sicht des Anbieters ist es statisch machbar.  Aus Sicht des Kunden ist es bequem, da man sich nur eine Unterkategorie auszusuchen braucht, ist aber problematisch, wenn der Request unten keine Unterkategorie fällt / eindeutig fällt. Die Suchmaschinen durchsuchen das ganze Web, kein Elekt. Katalog die Informationen sind durch den Anbieter beschränkt."
"data2_0_071.txt";"Elektronische Katalog: Anbieter, Kunde DB (Datenbank)"
"data2_0_072.txt";"Kostenersparnis für den Anwender Unabhängigkeit von z.B. Ladenöffnungszeiten für den Kunden Für Anbieter ist Distribution vereinfacht -> da direkt vom Online-Shop"
"data2_1_016.txt";"Elektronische Katalog: Anbieter:  Zusammenfassen verstreuter Informationen über z.B. Produkte, Preise auf verschiedene Web-Seiten in eine Seite, anhand beliebiger Kriterien kann Branchenmäßig, Industriezweig (horizontal, vertikal) geschehen Kunde: Angebote verschiedener Hersteller in einer Webseite integriert  Vorteile: Schneller Informationsgewinn Nachteile: Aktualität der Information ist entscheidend "
"data2_1_069.txt";"Hierunter versteht man die Informationsphase oder Wertschöpfungkette: elektr. Katalog: Waren bestellen Preise Bezahlung Transaktion"
"data2_2_001.txt";"Elektronischer Katalog ein Sortimentskatalog bei Firmen in elektronischer Form, der die Beschreibung der Produkte enthält. Hauptkomponente: Firmenname, Produktnummer, Produktbeschreibung, Preis, Zahlungs- und Lieferbedingungen Verwaltung von Kundenprofilen Vorteile für den Anbieter: er schafft sich eine neue Kundenbasis geringere Kosten für Marketing und Werbung Vorteile für den Kunden: Bequemlichkeit, 24h-Erreichtbarkeit, niedrige Preise, größere Auswahl, bessere Vergleichsmöglichkeiten, on-line Zahlungen kann auch mehrere Sprachen unterstützen"
"data2_2_010.txt";"Katalog ist das Produktverzeichnis eines Anbieters -> für Anbieter kostengünstige Möglichkeit, Produkte anzubieten und die Spezifikationen herauszustreichen für Kunden bequem an Angebot für Gut mit bestimmten Eigenschaften zu kommen"
"data2_2_011.txt";"Vorteile des elektronischen Katalogs aus Sicht des Anbieters: neuer Distributionsweg dadurch neue Kunden Umsatzerhöhung  Nachteile: elektronischer Hintergrund muß gesichert sein Probleme beim physischen Vertrieb Probleme bei Bezahlung  Vorteile für die Kunden: leichtere Preisvergleiche  leichtere Produktvergleiche man braucht nicht ins Geschäft gehen -> man kann Zeit sparen keine Öffungszeiten bequem  elektronischer Katalog: Presentation von Produkten im Netzwerk"
"data2_2_012.txt";"Hauptkomponenten:  Zahlungsfunktion Einkaufskorb Suchabfrage Kommunikationsmöglichkeiten (z.b. E-Mail)  Kunde:  24 Stunden abrufbar einfach und bequem mögliche Preisvorteile Preisvergleiche einfacher und schneller realisierbar  Anbieter: kostengünstig erhält Kundendaten kann Benutzerverhalten analysieren  zusätzlicher Vertriebsweg"
"data2_2_013.txt";"E-Katalog -> d. Angebot von Produkten (Diensten), Möglichkeit des Kaufes Haupkomponente: Produkte, Produktbeschreibungen, Preise, Zahlung-, Lieferungbedingungen  Vorteile für den Anbieter:  ein neuer Distributionsweg, niedrigere Kosten  Kundenprofile:  freiwillig von Kunden angegeben Kaufverhalten 1:1 Marketing  Zugriffsstatistik: auf welche Produkte (Produktkategorien) wird am meisten zugegriffen Gestaltung des Kataloges  Vorteile für die Kunden: virtueller Einskaufwagen, den Inthalt kann man bis zum nächsten Besuch behalten Auftragsbestätigung per e-mail Suche nach Produktgruppen, Produktbeschreibungen schnell, bequem, 24 Stunden Zugriff, ..."
"data2_2_018.txt";"Elektronischer Katalog: Zusammenstellung eines Angebots oder Sammlung relevanter Informationen in eine Datenbank  Die relevanten Informationen stellen eine Art ""Überschrift"" oder ""Schlagwort"" dar, nach dem von Kunde gesucht werden kann.  Die Datenbank beeinhaltet weitere relevante Informationen zu diesem spezifische Schlagwort. Beispiele: Bibliothekskataloge Vorteile Anbieter: leichtere Wartung, da nicht der ganze Katalog am neuesten Stand gehalten werden muß sondern nur seine relevanten Teile Vorteil Kunde: hat er sich einmal an das Handling gewöhnt, ist es eine schnelle + kostengünstige Informationsquelle"
"data2_2_042.txt";"Der häufigste Verwendungszweck von eKatalogen im Web ist der des Online Shops. Dort werden die Hauptkomponenten Produkt / Service, Preis und Transaktionsweg festgehatten (jedoch ändern sich diese Komponenten kontinuierlich). Aus der Sicht des Kundens ist dies eine sehr praktische Lösung sich zu informieren da dieser Dienst 24 Stunden verfügbar ist. Aus Sicht des Anbieters ist diese Möglichkeit sehr interessant da die Aufträge automatisch in seine EDV einfliesen können (zb. automatische Rechnungsaustellung ...)"
"data2_2_044.txt";"elektronischer Katalog listet Produkte eines Distributors auf auf und gibt genaue Beschreibung und Spezifikation dazu. Elektronische Kataloge vereinen vielfach das Angebot mehrerer Anbieter und haben somit größere Auswahl. Wenn mit dem Katalog die Möglichkeit eines tatsächlichen Einkaufs verbunden ist, spricht man von einem Verkaufskanal. => Einsparung im Vertrieb u. Marketing -> 1:1 Marketing u. Cross-Selling; 24h erreichbar"
"data2_2_046.txt";"elektron. Katalog ist ein Katalog der dynamisch aus einer Datenbank generiert wird -> Vorteil d. ständigen Übereinstimmung d. unternehmensinternen Daten mit dem Katalog auf d. Website Handling meist über Applicationserver und Enterprise Java Beans bzw. über aktive Server Seiten oder Servlets  Vorteile f. den Kunden rasche Suche Anpassung möglich Einkaufskorb kann auch später wieder aufgerufen werden (Sessionhandling zB über Session Beans und Entity Beans) Bestätigunsmails Ständige Abfrage des Lieferstarts möglich Bequemlichkeit 24 Stunden Verfügbarkeit evtl. mehrsprachig  Vorteile f. Unternehmen Anpassung an Bedürfnisse d. users möglich einheitlicher Datenbestand auf Website und in Unternehmens DB Kundenprofile können besser verwaltet werden Einsparungspotential durch verminderte Transaktionskosten Statistische Auswertungsmöglichkeiten erhöht Rabatt-Relevanz Entscheidungsbäume können eingestellt werden -> neue Absatzmöglichkeit"
"data2_2_047.txt";"Ein elektronischer Katalog ist eine Sammlung von Metadaten (z.B. Produkte: Produktinfo, Preis, ...) und Daten von (verschiedenen) Anbietern, der Kunden erlaubt effizient und schnell die gewünschte Ware zu suchen u. verschiedene Angebote zu vergleichen. Hat er die Ware gefunden, kann er auf elektronischem Weg eine Bestellung vornehmen, elektronisch bezahlen usw."
"data2_3_015.txt";"In einem elektronischen Katalog sollten alle Produkte vorhanden sein, die man anbietet Der Katalog sollte leicht zu navigieren sein. Produkte die ähnlich sind werden oft von mehreren Anbietern in einem e-Katalog angeboten Sicht des Kunden: man kann die Preise vergleichen, Produkte suchen und schneller finden, 24h Zugriff (d.h. man kann 24h einkaufen), von zu Hause aus, kein Zwischenhändler wird also Ware billiger Sicht des Anbieters: man erreicht eine größere Kundengruppe, Marketing wird billiger, kein Zwischenhändler mehr"
"data2_3_019.txt";"Ein elektronischer Katalog ist Sammlung v. relevanten Informationen in einer Datenbank. meistens ein Verzeichnis verschiedener Produkte eines Anbieters es kann auch auch Zusammenschluß verschiedener Kataloge mehrerer Anbieter zu einem Katalog erfolgen -> Katalogaggregation  d. Katalog besteht aus allg. Daten (Preis, Menge ...), wichtig ist die Suchfunktion f. d. Kunden, die komfortabel + effizient sein muß. (einfach zu benutzen, Suchfunktionen, 24h Verfügbarkeit) Ein Beispiel wären Bibliothekskataloge"
"data2_3_023.txt";"Elektronische Kataloge geifen auf Datenbanken zu, in denen sämtliche Informationen zu Produkten (z.B.: Bücher) zu finden sind. Hauptkomponenten: Web Client -> cgi -> Datenbank (DB) Anbietersicht: Anbieter hat Übersicht über Interessen der Kunden. Kundengerechtes Anbieten von Waren -> CRM Einsparung von Personalkosten, neuer Distributionskanal, interaktive Features, die dem Kunden Auswahl erleichtert Kundensicht: Shopping rund um die Uhr, Warenkorb- bzw. Einkaufswagenfunktion -> Kunde kann Ware vormerken und zu späterem Zeitpunkt kaufen Möglichkeit zu zusätzlicher Info zu Produkten (eventuell auch Erfahrungsaustausch mit anderen Kunden)"
"data2_3_030.txt";"Ein elektronischer Katalog bietet dem Kunden das Produkt und Dienstleistungsangebot eines oder mehrere Anbieter.  Er erhält so einfach Informationen über sein gewünschten Produkt. Der Anbieter kann statistische Auswertungen des Kundenverhaltens durchführen - induviduelle Seiten für jeden Kunden gestalten Der Käufer hat Zeitersparnis 24h pro Tag verfügbar Kostenersparnis einfacher Preisvergleich"
"data2_3_045.txt";"Ein Katalog ist ein im E-Commerce häufig verwendeter Marktplatz. Der Anbieter kann seine Daten wie (Lagerbestand, Preis, allgem. Geschäftsbed.) selbst verwalten Der Kunde kann Zahlungsbestätigungen, Kauf, Transfer kontrollieren"
"data2_3_048.txt";"Elektronische Kataloge werden hauptsächlich in Form von Datenbanken ins Internet gestellt. Früher gab es oft Eigenentwicklungen, heutzutage wird jedoch immer mehr auf Standardsoftware wie SAP umgestellt Oberfäch ist eine Internetsite von der aus man auf eine Datenbank zugreifen kann. Anbieter hat eben einerseits die Internetseite und andererseits die Datenbank für Generierung von Kundenprofilen Kunde sieht die Datenbank auf der Internetseite integriert. wird verwendet für Suche, Vergleiche"
"data2_3_049.txt";"Ein elektronischer Katalog beinhaltet Produktnamen, deren Preis, eine Beschreibung der Produkte und typischerweise auch Zahlungsbedingungen und Versandbestimmungen. Wenn der Kunde bestellt muß er gewisse Daten übermitteln. Der Anbieter sieht dann, welche Produkt ""gut gehen"" und welche schlechter. Er sieht auch die Kaufgewohnheiten der Kunden. Der Kunde sucht nur in jenem Bereich, der ihn interessiert. Andere Produkte bekommt er nicht zu Gesicht. Er kann sich auch mittels e-mails, die ihm zugeschickt werden, über Neuigkeiten auf dem Laufenden halten."
"data2_3_050.txt";"Aus Sicht des Kundens: man kann leicht die Preise vergleichen, übersichtlich, leicht zu suchen -> Suchmaschine 24 Stunden Zugriff darauf; praktisch, da von zu Hause aus anwendbar.  Aus Sicht des Anbieters: Marktauftritt leicht gemacht. Wettbewerbsfähig, große Zielgruppe ansprechbar, günstige Werbetätigkeit  Produkte, welche sich ähnlich sind werden meist in einem eigenen e-Katalog zusammengefaßt angeboten. in einem elektr. Katalog Sollen alle Produkte aufgelistet / angeführt sein. Prinzipiell sollte er leicht zu navigieren sein."
"data2_3_051.txt";"Ein elektronischer Katalog ist ein Katalog für Güter / Dienstleistungen der nur elektronisch verfügbar ist. Hauptkomponente ist die Präsentation des Angebotes. wichtig ist aber auch eine entsprechende Abfragemöglichkeit bezüglich der Produkteigenschaften / Preis / Leistung etc. / und natürlich auch eine entsprechende Bestellmöglichkeit."
"data2_3_052.txt";"Ein elektronischer Katalog listet die Produkte, deren Preise, und Informationen zur Abwicklung des Geschäfts auf. Der e-Katalog greift bei Anfragen eines Klients auf Produktdatenbank zu. Aus der Sicht des Kunden bietet mir der e-Katalog Vorteile wie Zeitersparnis und Bequemlichkeit, da ich anhand von Kriterien gezielt im Katalog ""blättern"" kann. Man kann die Verfügbarkeit eines Produktes abfragen. Aus der Sicht des Anbieters bringt es Einsparungen im Werbebereich. Durch Zählen der Seiten- / Produktabfragen kann gezielter gearbeitet werden, bessere Plazierung der Produkte nach Kundeninteresse"
"data2_4_002.txt";"Elektronische Katalog: Sammlung von Produkt- und Serviceinformationen von (vielen unterschiedlichen) Händlern, Unternehmer prasentiert auf einer Oberfläche (GUI) Hauptkomponenten: Productlistings, Produktdetailinfos, Kontakt, Bestellformulare, Preisvergleiche (umfassend) (Joyo) Sicht d. Anbieters: Wichtig: Positionierung v. Produkten Sicht d. Kunden: Produktinformationen, Preisvergleiche aus Sicht d. Kunden: Produktvergleiche (Information) Ordering, Bestellformulare, Verträge, Agents, Trl (Verhandlung) SET, eCash, Cybercash, Lieferung (Abwicklung) Hotlinie, After Sales Support aus Sicht d. Anbieters:  Welche Kunden, Benutzersinformationen (direkt Marketing, cookies) Preisfestsetzung, Formulare (Verhandlung) Sicherheit, (Abwicklung)"
"data2_4_003.txt";"Kunden suchen nach Produkten, bestellen und bezahlen über das Internet häufigster Verwendunszweck = Online Shop  Am weitesten verbreitete Anwerdung d. E-Comm. Koppelung des WWW an Produktdatenbanken PC d. Client (Kunden) http -> WWW Server <-> Händlen, elektr. Katalog <-> Produktdatenbank, Kundendatenbank"
"data2_4_020.txt";"Ein elektronischer Katalog ist dadurch gekennzeichnet, daß er sich dynamisch Daten aus ein Datenbank holen kann. Aus Administratorsicht ist die Datenbankpflege und -wartung wichtig, um immer auf aktuellstem Stand zu sein. Aus Kundensicht ist ein elektr. Katalog dafür geeignet, in Webshops einzukaufen evtl. hat dieser die Funktion einer Online-Warenverfügbarkeitsabfrage (Bsp: NRE.at)zusätzlich gibt es die Möglichkeit sich über das Produkt zu informieren und evtl. Preisvergleiche anzustellen (Bsp.: Geizhals.at) "
"data2_4_024.txt";"In einem elektronischen Katalog werden identische o. unterschiedliche Produkte angeboten, also man kann Kosten- u. Zeit einsparen, wenn man in einem solchen Katalog etw. sucht. Datenbanken werden ins Internet eingebunden, und übers Internet erfolgen auch Transaktionen. Zugriff meist über JAVA, CSS. Für Kunden schnelle Preisvergleiche, 24h Suche möglich, unter bequemen Umständen. Für die Verkäufer werden neue Absatzwege ermöglicht, oft Reduktion von Kosten, neue Services übers Internet. Besteht aus Internetseite (Homepage) -> Zugriff auf Datenbank"
"data2_4_028.txt";"Unter einem elektronischen Katalog versteht man ein ""Verzeichnis"" mit den angebotenen Produkten auf einer Internet-Seite. Die Kunden haben die Möglichkeit Produkte nach Suchbegriffen oder Kategorien zu suchen. Es zeichnet sich einen Trend aus, daß letzterzeit immer mehr elektronische Kataloge mit fertiger Software gemacht werden. Elektronische Kataloge ermöglichen für die Kunden einen schnelleren Preisvergleich für die Anbieter mehr potentielle Kunden."
"data2_4_031.txt";"Ein elekrtonischer Katalog ist eine Art Verzeichnis, in der verschiedene Produkte mit dazugehörigen Information gespeichert sind. Er besteht aus einer graphischen Oberfläche, die zur Kommunikation dient, und einer im Hintergrund liegenden Datenbank mit Produkt- bzw. Kundendaten. Funktion aus Sicht des Anbieters: direkten Kontakt zu Kunden Möglichkeit, eine Kundendatenbank aufzubauen Möglichkeit einer Verhaltensanalyse v. Kunden -> es können gezielte Angebote erstellt werden höhere Gewinne durch Verminderung der Lieferkette Funktion aus Sicht des Kunden: meist billiger als im herkömmlichen Handel Information aus erster Hand möglich Bestellung u. Bezahlung in einem Schritt  Ersparnis von Wegen weltweit verfügbar Möglichkeit des direkten Vergleichs -> hohe Preistransparenz "
"data2_4_034.txt";"Ein elektronischer Katalog ist eine web-Abbildung eines normalen Kataloges. Er erhält Produktinfos, Preise, Abbildung etc. Die Kundendaten + -einkaufsgewohnheiten können statistich ausgewertet + auch gleich f. den Kunden eingesetzt werden (siehe amazon.de, mit Buchvorschlägen für den eingelogten Kunden). Der Einkaufskorb kann zwischen Sitzungen gespeichert werden. Die Zahlungmögl. sind oft vielfältig. Meistens sind e-Kataloge schon Standardprod. + müssen nicht händisch programmiert werden. Die DB beinhalten Kundendaten, Artikeldaten u. -fotos, Preise, Liefer- u. Zahlungbedingungen, Statistiken "
"data2_4_037.txt";"Agglomeration von Angeboten versch. Unternehmen die thematisch zusammenpassen und auf einem Portal zusammengefaßt werden. Anbieter: übernimmt Daten von anbietenden Firmen, verwaltet nur Links Kunde: kann mit einem Portal mehrere Geschäftsangebote nutzen -> Vorteil: leichter Preisvergleich"
"data2_4_043.txt";"Elektronischer Katlog ist eine Datenbank mit Informationen über Produkt / Dienste die angeboten werden. Komponenten: Verzeichnisse, Bilder, Text, Adressen, Anbieter, Beschreibungen Anbieter, Administrator: gibt Informationen ein, ordnet sie, nimmt Infos heraus, aktualisiert Kunde: informiert sich indem er Informationen die im Katalog vorhanden sind nützt sie um weitere zu reasieren."
"data2_4_073.txt";"Ein elektronischer Katalog enthält die Produkte eines Anbieters (bei mehreren Anbietern nennt man es Katalogaggregation) man kann sich den elektronischen Katalog im Internet ansehen und ein gewünschtes Produkt bestellen. Haupkomponenten: Produktsuche Einkaufwagen in den man Produkte hineinlegen kann, die man kaufen möchte; ideal ist es, wenn der Einkaufswagen die Produkte ""speichert"" und beim nächsten Login wieder dort anzeigt (also in dem Fall, wenn man Produkte in den Einkaufswagen hineinlegt, aber doch nicht bestellt) Lagerstandanzeige: es sollte irgendwie markiert sein (zB. in den Farben grün oder rot) ob das Produkt in der gewünschten Menge lagernd ist oder nicht  Gliederung nach Produktgruppen"
"data2_5_005.txt";"Der Trend geht hin zur Verwendung von gekaufter Software. Hierbei werden meist vom Lieferanten die Daten in den Katalog eingegeben. Strukturierte Aufbereitung der Artikel/Informationen  Anbieter <-> E-Katalog <- Produktdaten, Kundendaten  Kunde:  Möglichkeit Communities beizutreten elektronische Bestellung Auftragsbestätigung Man kann genau feststellen, wo sich das Produkt befindet Abrechnung Einkaufskorb aktuelle Bestellmenge  Ein elektronischer Katalog bietet dem Kunden die Möglichkeit, aus vorhandenen Produkten durch strukturierte Suche auszuwählen, zu bestellen und den Wareneingang abzuwickeln  Produzent/Anbieter  Gutschriftverfahren leichtere/papierlose Abwicklung von Bestellungen und Rechnungen Verwaltet Katalog, da Dienst für Kunden (könnte besser sein, da dadurch Loyalität gewährleistet wird) 			Produktupdates von ihm am besten vorgenommen werden können Auswertung der Bestellstatistik Transaktionsnachverfolgung Generierung von Kundendaten"
"data2_5_008.txt";"Elektronische Katoge werden von Anbieter / Administrator dem Kunden zur Verfügung gestellt. Der Katalog beinhaltet Informationen über die angebotenen Artikel (Bezeichnung, Preise, etc.). Der Kunde sucht sich aus dem elektr. Katalog seine gewünschten Waren aus (Einkaufswagen). Der Anbieter stellt durch den elektr. Katalog sein komplettes Angebot on-line zur Verfügung  Intranet <-> WWW-Server <-> DB"
"data2_5_026.txt";"Ein elektronischer Katalog ist im Prinzip die digitale Abbildung eines gedruckten Kataloges listet Produkte mit deren Eigenschaften und Preisen (eventuell auch Bildern) auf man kann gezielt nach Produkten suchen Haupkomponenten: Daten, Datenbank über Produkte -> und Webserver, der allen Clienten die Suche im Katalog ermöglicht Anbieter: Kundenprofil erstellen, verwalten weltweite Verfügbarkeit -> kann weltweit anbieten diverse Zahlungssysteme möglich (auch alternativ zB.: SET oder Nachnahme) diverse Verkaufs / Marketingmechanismen anwendbar  Kunde: 24h Shopping Preisvergleiche Überblick über Produkt, Eigenschaft, Verfügbarkeit online Zahlung Währungsunabhängig bei Kreditcard payment Möglichkeit Produktvergleiche"
"data2_5_033.txt";"Ein elektronischer Katalog ist das im e-commerce am häufigsten eingesetzte Instrument zum Vertrieb. Es werden Datenbanken ins www eingespeist die von Konsumenten abgerufen werden können. Fällt unter die Kategorie der dynamischen Informationssysteme. Ist sehr individuell gestaltbar (sehr unterschiedlich) und wird in letzten Zeit immer mehr entwickelt statt zugekauft. Der Kunde hat die Vorteile daß er leicht die ganze Datenbank nach unterschiedlichen Kriterien durchsuchen kann, daß dies sehr rasch geht, relativ billig ist und er einen guten Preisvergleich hat. Die Informationen stehen ihm Rund um die Uhr recht einfach zur Verfügung. Der Anbieter hat den Vorteil daß er zB: gesammelte Kundendaten sammeln kann und so Kundenprifle erstellen kann und daß er z.B. Anzahl der Zugriffe (hits) auf ein bestimmtes Produkte zählen kam, Neuer Absatzweg"
"data2_5_035.txt";"Ein elektronischer Katalog ist die on-line zür Verfügung Stellung vom Katalog eines Unternehmen. Ein elektronischer Katalog besteht aus einem Artikelstamm mit mindestens einer Preisangabe. Er bietet auch Suchdienste für Kunden, nach Beschreibung, Preis usw. Er bietet Zahlungsmöglichkeiten."
"data2_5_036.txt";"Ein elektr. Katalog ist eine Datenbank, in der sämliche Produkte / Artikel gesucht und gefunden werden können = Online Shop Webclient -> CGI -> DB Sicht des Anbieters: Übersicht über die Interessen des Kunden  -> d.h. es läßt sich leicht feststellen, welche Kunden sich für welche Waren interessieren Einsparung von Personalkosten neuer Distributionskanal interaktive Features die das Bewerben der Produkte erleichtern / verbessern / optimieren Sicht des Kunden: Shopping rund um die Uhr Erfahrungsaustausch mit anderen Kunden (Bsp. Amazon -> Recommendation) mehr Auswahl Einkaufsmanager Funktion d.h. Kunde kann Waren aussuchen, aber erst später kaufen (bleiben im Einkaufswagen)"
"data2_5_053.txt";"Unter einem El. Katalog versteht man das Angebot an Gütern im Internet Zahlungssystem (Digi Cash, Kreditkarten, Inkasso, ...) Produktpalette (in Datenbank mit ihren Verfügbarkeit) Einkaufswagen, Vormerkliste für spätere Einkäufe, Angebote individuell Der Anbieter erwartet sich eine Kostenersparnis, ist nicht an Öffnungszeiten gebunden und die Vergleichbarkeit ist sehr einfach gegeben, da innerhalb kürzester Zeit, die Kosten für ein Konkurrenzprodukt ermittelt werden können Für der Anbieter ist die Distribution sehr leicht, da direkt vom Produzenten der online Shop geführt werden kann. daher fallen unter Umständen eine Reihe von Distributionskanälen weg. Der Lagebestand ist sehr leicht zu ermitteln und die Datenbank kann sehr leicht in andere betriebliche Anwendungen integriert werden, dadurch Personalkostenersparnis. Größtes Problem für Anbieter als auch Kunde ist die Sicherheit des Zahlungssystems "
"data2_5_054.txt";"Ein elektronischer Katalog besteht aus Daten, Datenbank, Metadaten über Daten und ist die digitale Abbildung eines analogen Katalogs. Entspricht einem Produktverzeichnis eines Anbieters, kann aber auch von mehreren Anbietern gleichzeitig sein = Katalogaggregation Funktion: Statistiken über Anzahl der Käufe für Anbieter Warenkorbsystem: Käufer kann Waren im Korb ablegen und auch erst viel später nach neuem einloggen diesen erweitern + die Bestellung durchführen Vorteil: große Preis + Markttransparenz"
"data2_5_055.txt";"Der Elektronische Katalog ist ähnlich dem Verstandhauskatalog die Möglichkeit dem Kunden die Produkte zu präsentieren. Prinzipiell besteht er aus Datenbanken (Kunden- und Produktdatenbank) auf die der Kunde über den Server Zugriff hat, um die gewünschten Infos zu suchen. Kunden-DB Kunde Produkt-DB  -> Elektr. Katalog  <-> Kunde  Sicht des Kunden: Informationsgewinnung elektronische Bestellung (Warenkorb) Auftragsbestätigung Zahlvarianten (elektronisch) leicht auffindbar Preis / Produktvergleich einfach zus. Infos durch Präferenzen ev. bessere Preise  Sicht des Anbieters: Abwicklung der Bestellung ist einfacher (kein Papier) Elektr. Katalog läßt sicht leicht umstellen bei Veränderungen / neuen Produkten Gütscheinsystem Kündenbindung / -infos durch ev. weitere Kontakte (via e-Mail) Kündenverhalten kennenlernen neue Absatzchancen geringer Personalaufwand"
"data2_5_056.txt";"Elektronischer Katalog z.B. Yahoo Darstellung als Tabelle, Bilderverknüpfung Möglichkeit zur Suche, Eintrag neuer Daten z.B. elektronischer Ersatzteilkatalog  Anbieter: Grunddaten auf CD Update übers Net Lauffähig ohne zusätzl. Software im Browser des Kunden Leistungsfähiger Server / DB notwendig Sammeln von E-mail Adressen durch Eintrag, Newsletter  Kunde:  leichte Suche Einfache Navigation kurze Antwortzeit, schnell Vollständigkeit Plattformunabhängigkeit  Komponenten: Application Server (verarbeitet JSP, Servlets, DB Abfragen WEB Server (verarbeitet http requests) DB (Infos)"
"data2_6_006.txt";"Ein elektronische Katalog ist eine Aggregation von verschiedenen einzelnen Katalogen der jeweiligen Verkäufer, die jeweils idente oder komplimentäre Produkte in einem gemeinsamen katalog darstellen  Web-Client --- WWW server --- cgi-script --- elektr. Katalog--- DB1, DB2 --- Produktdatenbank  Der Klient wählt eine Homepage, das cpi-script führt eine Abfrage auf die Produktdatenbanken aus und stellt dem Kunden die Abfrage in Form eines html-Textes zur Verfügung Der / Die Anbieter müssen keine statischen html-Seiten erstellen, sondern können durch Pflege der Produkt DB's die sie beispielsweise auch fürs innerbetriebliche System nutzen"
"data2_6_009.txt";"im Moment am weitesten verbreitet im E-Commerce ein dynamischer Katalog Die Daten werden ständig aktualisiert und bspw. unternehmensintern zwischen den Abteilungen synchronisiert -> Koppelung des Internet mit DataBases d. Prod.   Kundensicht: Registierung mit persönlichen Daten Suche/Ergänzungen des Kataloges relevante und aktuelle Information safe payments einfache Zahlungen evtl. Einkaufskorb  Admin-Sicht: Kataloginhalte verwalten, evtl. löschen Kundenprofile verwalten (Auswertungen) Auswertungen -> Marketing Auswertungen CRM Präsentation und Marketing des Site selbst"
"data2_6_021.txt";"= häufigste Anwendung von E-Commerce Einbindung von Datenbanken ins Internet (dynamisch. IS) Trend weg von Eigenentwicklungen, hin zur Integration in Standardsoftware wie SAP. Besteht aus einer Internetseite mit Zugriff auf eine Datenbank (z.B. über JAVA, aktive Serverseiten, CSS) Sicht d. Anbieters: Kundenprifle, Kostenersparnis bei Marketing + Vertrieb, neuer Absatzweg Kunden: 24h Suche, Preisvergleiche, Bequemlichkeit"
"data2_6_029.txt";"Ein el. Katalog = ein Katalog, der z.B. im Internet bereit steht und weitere spezielle Eigenschaften, wie Warenkorb, etc besitzt.  Er besteht aus einen Server, der den Katalog darstellt und einer Datenbank, die die Liste der Produkte enthält (Zugriff über CGI) Kundensicht: Der Kunde wählt ein Produkt aus und entscheidet sich es zu kaufen, oder er verläßt die Seite. Je übersichtlicher und bequemer die Seite, die mit Abbildungen und zusätzlichen Features versehen werden sollte, ist desto höher ist die Wahrscheinlichkeit eines Kaufes. Administrator = es wird ein Produkt angefordert  es wird auch die Datenbank zugegriffen dann über CGI wird eine Internet Seite erstellt und zur Verfügung gestellt"
"data2_6_038.txt";"Kunde -> i-net -> Händler -> e-Katalog -> DB (Abwicklung)  3 Phasen: Suchen - Aushandeln - ""Erhalten"" (Versand, ...)  Elektron. Katalog: weitgefaßter Begriff (z.B. Portal  mit vielen versch. Angeboten von versch. Produzenten) Entscheidend ist, daß der Kunde im Katalog  Informationen sucht und diese vom Anbieter  unter Zuhilfenahme einer DB aktuell gehalten werden  können. Ideales Beispiel: XML-Anwendung der 3. Generation:   Interne Anw. -> DB XML -> XML (HTML)  Dokument bzw. Angebot an Kunden erfolgt aktuelle (Pr., Verfügbarkeit) unter Zugriff a. die DB (von außen) Der Kunde kann das Angebot wählen und den Kauf abschließen, die Ware wird, etwa nach Bezahlung mit SE,T diesem Zugestellt."
"data2_6_057.txt";"elektronischer Katalog: Es ist ein virtueller Katalog, der Infos über Preise, Menge, Produkte anbietet Ablauf: Kunde erhält einem elektronischem Warenkorb, in den er sogenannte Produkte ablegen kann -> Bestätigung gespeichert -> Lieferweg nachverfolgen -> Einsparen v. Kosten durch größeren Mengen (Auswahl) Ablauf Anbieter: kann Stammdaten besser verwalten -> es kommt zu einer neuen Art der Kundenregistrierung -> kann die Kundendaten verwenden als Profile  (Kaufverhalten, Altersgruppe, Anzahl der Produkte) E-Katalog -> dynamisch, virtueller Katalog"
"data2_6_058.txt";"http -> WEB Server -> E-Katalog -> DB, DB  Hauptkomponenten: Info über Produkt und /oder Preis, Eigenschaften Funktionsweise (aus d. Sicht d. Anbieters): Kundenregistierung Verwaltung v. Kundendaten -> nützliche Info aus Konsumentenverhalten Einsparung von Kosten (keine Absatzmittler)  Funkt. weise a. d. sicht d. Kunden einfache Suche Möglichkeit d. Aufnahme in eine Community Bestellung Abwicklung Bezahlung "
"data2_6_059.txt";"Listen von Produkten / Services mit Preisen u. Beschreibungen; direkte Bestellung u. Geschäftsabwicklung / Initiierung von Transaktionen möglich; Komponenten: Listen, Bestellsystem, Einkaufskorb, Zahlung + Überprüfung + Bestätigung oft eingebaut: DB-Anbindung, Web-Server-Schnittstelle, Sicherheit (SSL, SET), WEB Tools, Offline-Testmoduls, Integration in betriebl. Standard-SW etc. für Anbieter: Kundenregistrierung, Kundenprofile (frw. Angaben / Kaufverhalten), Zugriffsstatistiken (-> Optimierung des Angebots / Produktpalette, Ranking der meistverkauften Güter) für Kunden: Suchmöglichkeiten (nach Produktgruppe, ...), virtueller Einkaufskorb (für später gespeichert), an induviduelle Interessen angepaßte Information aufgrund der Kundenprofile (z.b. amazon.com), Auftragsbestätigung per Mail, Abwicklungsstatus abrufbar, Online-Community"
"data2_6_060.txt";"el. Katalog: aggregiertes Angebot an Produkten das mehrere Produktgruppen von mehreren Anbietern enthalten kann, Produkte werden online angeboten, leicht zugänglich, außer Fixkosten fallen nur marginale Verkaufskosten an Funktionsweise: Administrator: bietet Güter online an, erhält Kaufaufträge von Kunden, liefert die Güter physisch und erhält die Zahlung via IPS Kunde: bestellt Ware, zahlt online, erhält Güter geliefert -> Zeitersparnis, Kostenersparnis"
"data2_6_061.txt";"e catalogue ist digitalisiertes Produkteverzeichnis eines oder mehrerer Anbieter (Katalogaggregation) eKatalog muß aus mehreren Komponenten bestehen, wie z.B. Infos über Produkt, Produkt, Produktauswahl, Bestellung, AGB für Bestellung, Lieferbedingungen, Zahlungmöglichkeiten Anbieter soll übersichtlich seine Produkte darstellen können.  Vorteile Kostensenkung durch eMarketing, eDistribution zB. von digitalen Güter, sowie zB. die GKosten bei digital. Güter = 0, Probleme bei der Logistik von nicht-digitalen Gütern, sowie bei Micropayments, da hohe Transaktionskosten Kunde kann komfortabel einkaufen, Zeit sparen, günstig einkaufen -> die Ware muß verfügbar, für jeden zugänglich sein Administrator: Zugriffskennung, Zugriffsverweigerung, Zahlungssystem, Sicherheit der Daten"
"data2_7_004.txt";"Ein elektr. Katalog ist sie digitale Abbildung eines analogen Kataloges Funktion: aus Sicht d. Kunden: Es werden Produkte, die digital vermarktbar sind, beschrieben; Es kann gezielt u. schnell n. nach Produkten bzw. Produkteigenschaften gesucht werden Hauptbestandteile: Daten, Datenbank, Metadaten über Daten Funkt. d. (Admin.) Anbieter: Statistiken über Anzahl d. Käufe bzw. Verkäufer können erhoben worden; Eis können Customer Profile angelegt werden z.B.: demographische Daten d. Kunden"
"data2_7_007.txt";"Unter einem elektronischen Katalog versteht man die Präsentation von Produkte oder allgemein Leistungen auf elektronischem Weg Präsentation in Bild, Text (Beschreibung), Informationen über Preis, Zahlungsmöglichkeiten -> Mit dem elektr. Katalog ist eine Kaufmöglichkeit einbezogen. Diesbezüglich sind folgende Komponenten notwendig:  Produktvisualisierung , Beschreibung (Produktdatenbank) Verkaufsplattform mit ensprechenden Sicherheitsvorkehrungen, (Warenkorb, Variation der Zahlungmodi, ...) Logistischer Bereich um die Kaufanfragen und die anstehenden Lieferungen zu meistern Funktioweise: Anbieter:  Registrierdatenbank führen -> Kundenregistrierung eintragen Bestellung mit Zahlungmodus entgegennehmen Lieferung starten  Kunde: Registierung, Einverständnis zu AGB's Auswahl des Produktes -> Warenkorb Weitere Auswahl treffen oder zum Zahlen übergehen  Bestätigung ausdrucken"
"data2_7_022.txt";"Der Kunde hat verschiedene Möglichkeiten seine ""Ware"" zu suchen, mittels Detail-Suche, Volltext-Suche etc. Er kann mittels E-Mail eine Auftragsbestätigung erhalten. Er hat die Möglichkeit zwischen verschiedenen Sprachen zu wählen. Und mittels eines Einkaufwagen kann er seine Waren speichern und beim nächsten Aufruf wieder darauf zugreifen. Der Administrator kann die Kd-Daten verwalten, er kann Profile erstellen. Und er kann verschiedene Statistiken für seine Waren erstellen. Beim einem elektr. Katalog, ist ein Katalog online abrufbar. Er besteht aus den Hauptkomponenten: Waren Bestellung Anmeldung Anfragen E-Mail Suchdienste Werbebanner"
"data2_7_027.txt";"Ein elektronischer Katalog ist eine Liste von Gütern die man über das Internet beziehen kann. Er besteht meistens aus einer Produktdatenbank (wenn möglich mit Lagerstandsanzeige), eines Kunden, einer Bestellmöglichkeit, einer Zahlungsabwicklung, einer Verständigung des Kunden bei erfolgreicher Bestellung Der Administrator muß neue Produkte aufnehmen bzw. bestimmte Produkte herausnehmen, Lagerbestand überprüfen, sich um Produkangebote kümmern Der Kunde hat einen Warenkorb in den er bestimmte Güter aus dem Katalog übernimmt. Meist erfolgt die Zahlung über Kreditkarte."
"data2_7_041.txt";"elektr. Kataloge dienen der Aggregation v. Daten über bestimmte Produkte Aus der Sicht des Kunden kann ein elektr. Kat. Produkte suchen, Preisvergleiche machen, Summe der Einkäufe und daraus Steuern rechnen. Bei erfolgter Bestellung erhält der Kunde ein email, während der Lieferzeit kann der Kunde abfragen in welcher Phase das bestellte Produkt ist (bsp. ob es schon geliefert wird). Einkaufswagenfkt. Der Anbieter kann mit Hilfe der elektr. Kataloge die Kundenprofile verwalten, Statistiken erstellen, Entscheidungsbäume für Rabatte, Skonto rechnen. Unterstützt werden auch: Zahlung und Logistiksysteme Hauptkomponente: Homepage, Datenbanken"
"data2_7_062.txt";"Ein Elektronischer Katalog wird üblicherweise von den Anbietern der im Katalog beschriebenen Dienste erstellt und enthält für den Kunden veschiedene Informationen über die Produkte bzw. Leistungen Angefangen bei Spezifikationen u. dem Preis bis zu einer Such- u. Bestellmöglichkeit z.B. durch sogenannte Wareneinkaufskörbe. Der Kunde sucht nach verschiedenen Kriterien seine gewünschte Ware und erhält eine od. mehrere Waren zur Auswahl, entscheidet der Kunde sich für eine bestimmte Ware kann er sie in den meisten Fallen auch online bestellen. Der Anbieter seinerseits kann durch Erstellen einer Datenbank seine Waren od. Leistungen erfassen u. sie online stellen (hier bieten sich natürlich interaktive Datenbanken an ) Durch Einkäufe werden die Bestandsveränderungen erfasst eben sowie durch Verkäufe. Der Administrator erhält ein Bestellformular der Kunden und entscheidet je noch Modernisierungsgrad (ob er dieses Formular selbst bearbeiten muß od. es durch interaktive Datenbank bereits online erfasst wird."
"data2_7_063.txt";"Sammlung von den verschiedensten Produkten (und deren Daten) in einem IT-System um diese den Kunden online zum Kauf anzubieten User Interface: optische Bereitstellung der Produkte Datenbank: Speicherung der Produktdaten und Kundendaten Anbieter: stellt die Produktdaten in die Datenbank, erhält die Bestellung vom Kunden, Auftragsbearbeitung, verschickt die Produkte Kunde: Auswahl der Produkte im User Interface, Registrierung beim Anwenden, Bestellung der Ware, Erhalt der Ware, Bezahlung der Ware (hängt von der Art der Bestellung ab)"
"data2_7_064.txt";"Elektronischer Katalog ist eine Datenbank mit Internet in der Produkte u. Services gespeichert werden. Komponenten: Verzeichnisse von Produkten, Anbieter, Produkte, Beschreibungen, Adressen Funktionsweise: Anbieter: Gibt Informationen ein und aktualisirt D. diese, Kundenprofil, Marketing, Auswertung, CRM Kunden: benutzt Datenbank, kann sich über Hierarchie zu bis zur entsprechenden Produktklasse ""hinunterhanteln"" u in  Registierung von persönlichen Daten dynamische u. aktuelle Datenbank "
"data2_7_065.txt";"Unter einem elektronischen Katalog versteht man die ""Portierung"" eines Produktkataloges (mit Preisen etc.) in eine Datenbank. Diese läßt sich meist über ein Webinterface abfragen. Bsp. geizhals.at Auch Einbindungen für den online-Einkauf sind möglich und üblich -> Auch Suchfunktionen und Shop-Lösungen (mit Warenkorb Bsp. amazon.de) heute an der Tagesordnung. Vorteile von einem Elektronischem Katalog: Kunde kann die genauen Spezifikationen, Preis ... 24h online abfragen und sich zB.: dr. Java.Applets mit dem Produkt beschäftigen Preisvergleiche werden dr. Elektr. Kat. erheblich vereinfacht. -> Markttransparenz -> weiterer Absatzkanal für den Produzenten Funktionsweise aus Sicht des Einkäufers Suche im Katalog -> gewähltes Produkt zum Warenkorb hinzufügen -> Einkauf abschicken (Bezahlungsart wählen, Adresse ...) -> Abwicklung der Bez. dr. zB. Kreditkartenorganisation Sicht d. Verkaufers: Erstellung d. Kataloges -> Programmierung der DB Abfrage -> ... ev. automatische Preisänderungen mit einprogrammieren (hohe Nachfrage erhöht generisch den Preis .."
"data2_8_014.txt";"Ein elektronischer Katalog ist meist eine Produktdatenbank mit WWW-Interface Ermöglicht Finden, Bestellen und Bezahlen eines Gutes  Funktionsweise für Kunden:  speicherbarer Einkaufswagen komplexe Suchfunktionen personalisierbares Angebot sicheres Bezahlen Order Tracking  Für Admins:  Sammeln von Käuferinformationen durch freiwillige Angabe, Kaufverhalten Statistiken aus gesammeltem Material  Entscheidungsbasis für Spezialangebote / Rabattsysteme Auswertung der Kundendaten  mögl. Aufbau: HTTP server -> Application Serven -> DB Server"
"data2_8_040.txt";"Interagent mit dem User Einkaufswagen: merkt sich Ware für das nachste Mal für Anbieter: Kundendatenverwaltung, Kundenadministration   Web Browser <-> WWW Server <-> el. Katalog <-> Produktdatenbank, Kundendatenbank Kunde        HTTP                Händler  Katalog der dynamisch ist -> Applicationsserver Ständige Abstimmung und unternehmensinternen Daten -> auf Website Anpassung an Kundendaten Kunde 24 Bereitschaft schneller Preisvergleich höhere Bequemlichkeit rasche Suche Anpassung an Kundendaten   Anbieter: Kundenprofile sammeln, bessere Verwaltung der Kundendaten spart sich Intermediare und kann Preisvorteil zu Kunde weitergeben Kostenersparnis in Marketing Auswertungen, CRM Marketing"
"data2_8_066.txt";"Elektronischer Katalog (EK) dient zur Vewaltung von Produkten / Services, zum Anhängen von Attributen an Produkte zB. Preis, Größe, ...  Anwendungsbsp: Online Shop   Frontend      <-> DB                     -> andere techn                                              Systeme Clientansicht     Verwaltung                Billing, Logistiks, SAP                   Produkte und Metadaten  Funktionsweise: Kunde: Suchfunktionen Ausgrennzungsfunktionen (Preisgrenzen...) Einkaufswagen (inkl. Cookies) Statistiken  Anbieter: leichtes Ändern von Metadaten leichte Verwaltung Speicherung von Kundendaten: Kaufshistorie, Clustering, bessere Eimpfehlungen  "
"data2_8_067.txt";"Im elektronischen Katalog werden Produkte (Infos, Preise, usw.) gespeichert und ermöglichen es dem Kunden z.B: Informationen über Produkte einzuholen und zu bestellen; Katalog besteht aus einer Datenbank, in der Produkte gespeichert sind; diese DB liegt auf einem Server; Kunden greifen über Internet auf die Informationen zu; Anbieter: füllt DB mit Daten; meistens schon mit Artikelverwaltungsprogramm verbunden; hat Softwarekomponente die Bestellung wartet Kunde: öffnet Katalog im Internet; informiert sich über Produkte; hat Suchmöglichkeiten; kann sich als Benutzer registrieren (ev. Rabatte) , wählt Produkt aus -> Warenkorb -> speichert Artikel -> kann Bestellung abschicken; sichere Verbindung (z.B: SSL) -> verschiedene Zahlungsarten"
"data3_0_041.txt";"Kommunikationsziel: Mit welchem Medium wurde der grüne Veltliner am stärksten erreicht? A: Mit dem Freizeitjournal werden die angegebene Klientel für den angegebenen Auftrag erreicht."
"data3_0_042.txt";"Ich würde Plan 1 auswählen da die ""Opportunity to see"" bei Plan 1 22 beträgt und höher ist als bei Plan 2. Ich muss möglichst viele Personen erreichen um zum ausprobieren ermuntern zu können. Es hilft nichts wenn ich nach den Kosten auswähle."
"data3_0_043.txt";"Plan 1 Plan 1 hat mit 22 OTS Punkten die höchste Tiefenwirkung in der Zielgruppe aller Weißweintrinkerinnen Österreichs, also die höchste Kontaktchance. Auch die Kosten des Plans sind geringer als bei Plan 2."
"data3_2_040.txt";"Plan 2: da ich durch minimale Mehrkosten für die Schaltungen -> mehr Schaltungen habe und -> eine wesentlich größere Reichweite sowohl gesamt als auch in der Zielgruppe"
"data3_3_036.txt";"Plan 2 erscheint wesentlich besser, da um beinahe die gleichen Kosten mehr Schaltungen mit einer wesentlich höheren Reichweite erreicht werden können (+ 20 %) Auch die Kosten / 1000 Nutzer sind deutlich geringer!"
"data3_3_037.txt";"Plan 2 eigent sich am besten, da er eine hohe Breitenwirkung (80 %) erzielt, die Tiefenwirkung nur wenig geringer ist (OTS von 20 zu OTS Plan 1 von 22) und auch die Gesamtkosten nur wenig höher liegen. Außerdem ist der 1000 Nutzer Preis und der 1000 Kontakte Preis bei Plan 2 kleiner. Man möchte ja möglichst viele Weintrinker erreichen => Plan mit höherer Breitenwirkung = Plan 2"
"data3_3_038.txt";"Plan 2 brächte sehr hohe Reichweite -> Breitenwirkung und bei Plan 2 mit 80 % gegeben. Auch sind mein 1000 Kontakte Preis und mein 1000 Nutzer Preis geringer als bei Plan 1."
"data3_3_039.txt";"Plan 2: Streuung in allen genannten Medien bessere Breitenwirkung (80 % Reichweite) Tiefenwirkung zwar geringer (um 2 Durchschnittskontaktchancen) er ist zwar der teurere (3000 ) -> eher gering allerdings hat er das bessere Preis / Leistungsverhältnis (1000 Kontakte Preis: 15,81 , 1000 Nutzer Preis: 316,25 ) mehr Schaltungen -> öftere Wiederholung der Werbung, Präsenz ist gut geeignet um Bekanntheit zu  erlangen."
"data3_4_013.txt";"Ich würde Plan 2 präferieren, weil es große Unterschiede in der Reichweite gibt -> Plan 2 erreicht um 20 % mehr Leute als Plan 1 Plan 2 ist zwar billiger (1000 Kontakt Preise) aber hier gibt es nicht so großen Unterschied wie bei der Reichweite die Tiefenwirkung ist nur gering weniger als wie bei Plan 1."
"data3_4_014.txt";"Plan 2 Die Reichweite (Breitenwirkung) in der Zielgruppe ist höher als in Plan 1 (80 %) [also  nicht inferior]. Die Durchschnittskontaktchancen sind höher 16. Sowohl die Kosten für den 1000er  Nutzer Preis (316) als auch die Kosten  pro 1000 Kontakte (15,8) sind geringer als bei Plan 1."
"data3_4_015.txt";"Ich würde Plan 2 wählen, da er die höchste Reichweite in der Zielgruppe hat (80 %), die niedrigeren Kosten / 1000 Nutzer (316 : 417) und in Folge auch die niedrigeren Kosten / 1000 Kontakte (16,-) Der OTS Wert ist zwar geringer, das ist aber nur ein geringfügiger Unterschied im Vergleich zum Kostenvorteil und der höheren Reichweite"
"data3_4_016.txt";"Plan 2 Die Gesamtkosten sind zwar leicht höher die 1000 Kosten spiegeln aber ein deutlich besseres Preis Leistungsverhältnis wieder. Die Reichweite ist wesentlich höher und die OTS sind nicht deutlich schlechter. Prinzipiell könnte man sich auch gegen Plan 1 entscheiden da eine Reichweite von 60 % eine zu geringe Breitenwirkung hat Darüber hinaus ist bei Plan 2 anzunehmen, dass Gusto eine hohe Zielgruppenattraktivität erzielen wird."
"data3_4_017.txt";"Plan 2 ist besser geeignet, da das Ziel nur das Ausprobieren ist, daher sind 20 OTS ausreichend die Kosten annähernd gleich die Reichweite viel höher (wichtig!) die höheren Kontakt / Nutzer Preise vertretbar"
"data3_4_018.txt";"Plan 2, da 80 % Reichweite, größere Breitenwirkung, Tiefenwirkung OTS ist nicht viel schlechter als in Plan 1 und auch nicht viel teurer. Kosten / 1000 Nutzer billiger"
"data3_4_019.txt";"Ich würde Plan 2 wählen da: er eine höhere Reichweite hat da 1000 Nutzer Preise und 1000 Kontakt Preise niedriger ist da OTS ist um 2 Kontaktchancen niedriger da gesamte Plan ist zwar etwas teurer aber nicht sehr. Da möglichst viele Personen den Wein probieren sollen ist die Reichweite wichtiger als die OTS."
"data3_4_020.txt";"Ich würde mich für Plan 2 entscheiden, da er zwar eine Spur teurer ist, aber eine Reichweite von 80 % besitzt (60 % Plan 1) => Breitenwirkung und die Kosten bei 1000 Nutzer Preise, 1000 Kontakte Preise auch geringer sind. Durchschnittskontaktchance (OTS, Opportunity to see) liegt mit 20 nur 2 Punkte hinter Plan 1."
"data3_4_021.txt";"Plan 2: Kosten nur geringfügig höher Reichweite um 20 % über Plan 1 OTS fast ident (20 = guter Wert) klar besseres Preis / Leistungsverhältnis"
"data3_4_022.txt";"Da man alle Weintrinker in Österreich erreichen will, sollte eine große Reichweite durch den Mediaplan herauskommen => Plan 2 => 80 % der Zielgruppe wird erreicht Plan 2 hat geringeres Preis Leistungsverhälntis => 1000 Nutzer Preis 316 => 1000 Kontakt Preis 16 Plan 2 hat eine große Breitenwirkung und damit geringere Tiefenwirkung (20 OTS) Plan 2 sollte gewählt werden"
"data3_4_023.txt";"Entscheidung für Plan 2, da er sowohl eine hohe Breitenwirkung (Reichweite 80 %) als auch eine zu Plan 1 vergleichbare Tiefenwirkung (OTS 20) erzielt. Dadurch sind auch die Kontakt- und  Nutzer Preise in 1000 billiger als bei Plan 1 hohe Breitenwirkung -> viele sollen erreicht werden -> ziehlt eher auf die Markenbekanntheit ab hohe Tiefenwirkung -> Erreichte sollen animiert werden, etwas zu tun -> zielt eher auf das Image ab"
"data3_4_024.txt";"Plan 2, weil geringere Kosten, höhere Reichweite die Durchschnittskontaktchancen sind bei beiden ziemlich gleich. (Plan 1 würde man nur wählen wenn man höhere Kosten in Kauf nimmt, aber die Durchschnittskontaktdaten sind höher als Plan 2, jedoch ist die Reichweite zu gering)."
"data3_4_025.txt";"Entscheidung für Plan 2, welcher von den Gesamtkosten nur marginal über Plan 1 liegt, aber folgende Vorzüge hat: höhere absolute Reichweite in der Zielgruppe, daraus folgt höhere prozentuelle Reichweite in der Zielgruppe höhere Kontaktsumme bei nur unwesentlich niedrigerem OTS-Wert (der aber unter dem Aspekt der Breitenwirkung noch dazu zu relativieren ist) niedrigerer 1000 Nutzer Preis niedrigerer 1000 Kontakte Preis"
"data3_4_026.txt";"Es sollte Plan 2 gewählt werden, da er eine höhere Breite aufweist da er zusätzlich den Werbeträger Gusto beinhaltet eine höhere Reichweite (80 %) in der Zielgruppe hat die Wirkungstiefe von 20 Kontaktchancen ist im Vergleich zu Plan 1 mit 22 Kontaktchancen zwar weniger aber dennoch völlig  ausreichend Preislich stark unter Plan 1 liegt und somit deutlich kostengünstiger ist"
"data3_4_027.txt";"Ich wähle Plan 2 da die Reichweite in der Zielgruppe größer ist als in Plan 1 die Kontaktchancen mit 20 genügend groß sind und sowohl die Kosten pro 1000 Nutzer und Kosten pro 1000 Kontakte"
"data3_4_028.txt";"Plan 2: die Breitenwirkung mit 80 % wesentlich höher und auch die 1000 Nutzer Preise und die 1000 Kontakte Preise wesentlich günstiger Ich wähle diesen Plan obwohl Plan 1 einen besseren OTB-Wert (Tiefenwirkung) hat, deswegen, weil er bei allen anderen kennzahlen wesentlich besser abschneidet und ein OTB-Wert von 20 sehr gut ist (jeder Weintrinker hat bis zu 20 Wiederholungschancen)"
"data3_4_029.txt";"Plan 2! Breitenwirkung ist mit 80 % Reichweite deutlich höher OTS ist 16 (sollte mindestens 15 (hier erreicht) um ausreichende Tiefenwirkung zu haben) 1000 Kontakte Preis ist etwas geringer als bei Plan 1 nur 1000 Nutzer Preis ist etwas höher als bei Plan 1"
"data3_4_030.txt";"Um das Kommunikationsziel erreichen zu können sollte Mediaplan 2 ausgewählt werden, obwohl die Kosten höher sind => aufgrund mehrerer Kriterien Plan 2 erreicht 80 % (Breitenwirkung) der Zielgruppe (vs. 60 % => Plan 1) Plan 2 hat den weitaus günstigeren 1000 Nutzer Preis (100 !) und den günstigeren 1000 Kontakte Preis d.h. Plan 2 bietet das bessere Preis Leistungsverhältnis Tiefenwirkung etwas schlechter! OTS sind zwar um 2 weniger als in Plan 1 jedoch bietet Plan 2 die bessere Breitenwirkung"
"data3_4_031.txt";"1000 Nutzer Preis = Vergleich des Preis Leistungs Verhältnisses Plan 2 -> da die Durchschnittskontaktchancen bei 20 OTS liegen (nur 2 OTS unter Plan 1) die Reichweite aber mit 80 % weit über Plan 1 liegt. Bei Plan 1 wird ja fast die Hälfte (40 %) der Zielgruppe nicht erreicht. Abgesehen davon ist Plan 2 bezüglich der 1000 Nutzer Preise mit 316  Plan 1 überlegen; die höheren Gesamtkosten um 3000  sind zu vernachlässigen."
"data3_4_032.txt";"Plan 2: hat mit OTS = 20 zwar die geringere Tiefenwirkung der beiden Mediapläne, jedoch die deutlich höhere Breitenwirkung (80 % der Zielgruppe). Außerdem sind die Kosten / 1000 Leser Kosten / 1000 Nutzer um ein deutliches geringer als bei Plan 1. Die Gesamtkosten sind annähernd gleich hoch wie bei Plan 1. Konklusio: Ich würde Plan 2 wählen, er hat zwar um 2 OTS die geringere Tiefenwirkung, dennoch kann ich um 20 % mehr Breitenwirkung und geringere Kosten bei den Lesern und Nutzern erreichen."
"data3_4_033.txt";"Plan 2: Begründung: Plan 2 hat mit 80 % die höhere Reichweite (60 % Plan 1) und dies ist auch die  wichtigste Kennzahl. Außerdem weist er auch sowohl bei den 1000 Nutzer Kosten, wie auch den 1000 Kontakt Kosten die geringeren Kosten auf (wenn auch nur in einer eher knappen Abweichung zu Plan 1) Bei den Durchschnittlichen Kontaktchancen hat er mit 20 zwar einen geringeren Wert als Plan 1 mit 22, doch ist dies nur ein sehr geringer Unterschied. Auch der Unterschied bei den gesamten Plankosten ist sehr gering (Plan 2 um 3000 teurer) und daher denke ich sind die Reichweite, 1000 Nutzer Preise, und 1000 Kontakt Preise ausschlaggebend für Plan 2."
"data3_4_034.txt";"In diesem Fall muss man sich für Plan 2 entscheiden. Die Reichweite ist mit 80 % weit höher als bei Plan 1. Die durchschnittlichen Kontaktchancen sind mit zwei weniger nicht viel geringer und auch das Preis / Leistungsverhältnis ist besser (1000 Nutzer Preise) Breitenwirkung und tiefenwirkung sind in Ordnung, womit das Kommunikationsziel besser erreicht werden kann."
"data3_4_035.txt";"Ich wähle Plan 2: die Weinmarketinggesellschaft möchte alle regelmäßigen Weintrinker erreichen, daher ist eine möglichst große Breitenwirkung zu erzielen. Sowohl die Reichweite der Zielgruppe als auch die Breitenreichweite ist in Plan 2 besser als in Plan 1. Die Tiefenwirkung ist zwar in Plan 2 schlechter (20 OTS Punkte), aber nur minimal."
"data3_5_001.txt";"Ziel = Aufforderung zum Ausprobieren -> möglichst hohe  Breitenwirkung (-> Reichweite!) Entscheidung für Plan 2, da höhere Reichweite und außerdem auch niedrigere 1000 Nutzer Preise, 1000 Kontakte Preise (-> besseres Preis Leistungs Verhältnis) Durchschnittskontaktchance (OTS) ist mit 20 auch sehr gut und Reichweite unwesentlich schlechter als bei Plan 1 (22)"
"data3_5_002.txt";"Ich wähle Plan 2, da die Reichweite von 80 % um 20 % höher liegt als bei Plan 1 und sich die österreichische Weinmarketinggesellschaft das Ziel gesetzt hat möglichst viele Weintrinker zum Probieren zu ermuntern. Auch bei den OTS Werten liegt Plan 2 nur um 2 Punkte zurück (nur geringe Abweichung) Kosten pro 1000 Nutzer bzw. Kontakte sind zwar in diesem Fall nicht so interessant, liegen aber deutlich niedriger als bei Plan 1 (obwohl die Gesamtkosten des Plans etwas höher sind)"
"data3_5_004.txt";"Plan 2, weil er eine viel größere Breitenwirkung besitzt (Reichweite 80 %), während Plan 1 nur annähernd die Hälfte der Zielpersonen erreicht. Im Durchschnitt 20 Kontakte zu Weintrinkerinnen sind sehr gut und nahezu gleich mit Plan 1 der 2 Personen mehr kontaktiert. Das Preis Leistungs Verhältnis ist auch auf jeden Fall im Plan 2 besser: hier sind die Kosten pro 1000 Nutzer weit geringer, ebenso die Kosten pro 1000 Kontakte um 3. Dazu ist Plan 2 nur geringfüfig teurer (3000) als Plan 1. Summa Summarum weist Plan 2 eine sehr gute Breiten- und Tiefenwirkung auf, der mit hoher Wahrscheinlichkeit das angepeilte Ziel erreichen wird!"
"data3_5_005.txt";"Mit Plan 2 werde ich das Kommunikationsziel am ehesten erreichen, da die Reichweite Breitenwirkung (80 %) und die Tiefenwirkung ausreichen sollten (OTS = 20) um das Kommunikationsziel zu erreichen. Bei Plan 1 ist die Breitenwirkung mit 60 % viel zu gering. Die Kosten pro 1000 Nutzer und 1000 Kontakte sprechen auch für Plan 2."
"data3_5_006.txt";"Plan 2 Weil: größere Reichweite (= Breitenwirkung) Ich unterstelle den Weißweintrinkern hohes Involvement bei Qualitätsweinen -> Verzichte auf minimalen  (2 Kontakte / Nutzer) Vorteil bei Tiefenwirkung (bei Plan 1), 20 OTS sind  völlig genug Preis ist zwar ein wenig höher (3000 ) aber  1000 Nutzer Preise und 1000 Kontakte Preise sind viel niedriger (1000 Nutzer Preise um fast 25 %)"
"data3_5_008.txt";"Wähle Plan 2 -> möchte, dass viele Personen aus meiner Zielgrupe Wein probieren -> brauche hohe Breitenwirkung -> Plan 2 80 % (statt 60 % bei Plan 1) 1000 Nutzer Preise und 1000 Kontakte Preise auch niedriger als in Plan 1 OTS nur um 2 Kontakte weniger -> auch nicht so schlecht"
"data3_5_009.txt";"Plan 2 ist klar zu bevorzugen. Die Reichweite von 80 % ist gut (optimal: > 80 %), die OTS von 16 (also 16 Kontaktchancen pro Person) sind sehr gut. Beide dieser Werte liegen also über Plan 1. Noch dazu sind der 1000 Nutzer Preis  von Plan 2 und der 1000 Kontakte Preis unter dem Preis von Plan 1. Plan 2 kostet insgesamt um 3000  mehr, aber da das Ergebnis der Kennzahlen so deutlich ausfällt, kann hier nur Plan 2 in Betracht gezogen werden!"
"data3_5_011.txt";"Man muss große Zielgruppe (1 Million) zum Ausprobieren bewegen -> d.h. möglichst viele Zielpersonen erreichen -> braucht große Breitenwirkung -> Plan 2 erfüllt Anforderung. Plan 2 hat außerdem besseres Preis-Leistungsverhältnis (1000 Nutzer Preise = 316,- -> kostet soviel um 1000 Zielpersonen zu erreichen) außerdem mit OTS Wert nicht viel schlechter als Plan 1 (nur 2 OTS Punkte Unterscheid) => wähle Plan 2!"
"data3_5_012.txt";"Bei der Wahl kommt es darauf an, ob ich Breitenwirkung (Reichweite) oder Tiefenwirkung (OTS) erzielen will (zB bei  Imageverbesserung). Hier sollte meiner Meinung nach Plan 2 gewählt werden, da die OTS fast gleich sind 22 Plan 1 - 20 Plan 2 = kein großer Unterschied, doch die Kosten pro 1000 Nutzer und Kosten pro 1000 Kontakte bei Plan 2 billiger sind (Nutzer: 2 um 101,- , Kontakte 2 um 3  günstiger als 1)"
"data5_01.txt";"Kashyap klassifiziert Metadaten (Daten über Daten) in folgende Kategorien. Inhaltsunabhängige Metadaten (Content-independent metadata): Dieser Datentyp sammelt Informationen welche unabhängig vom Inhalt sind. Beispiele: Speicherzelle (Speicherort), Modifikationsdatum. Inhaltsabhängige Metadaten (Content-dependent metadata): dieser Metadatentyp hängt vom Inhalt ab. Beispiele: Dokumentgröße, Anzahl der Reihen/Spalten. Diese Daten können wiederum unterteilt werden. Direkt inhaltsabhängige Metadaten (direkt content-based metadata): Dieser Metadatentyp hängt direkt vom Inhalt ab. Beispiele: Volltextanzeigen. Inhaltsbeschreibende Metadaten (Content-descriptive metadata): Dieser beschreibt den Inhalt ohne den direkten Nutzen daraus und beinhaltet den Gebrauch von Wissen oder menschlichen Sichtweisen und Erkenntnissen. Beispiele: Duft eines Blumenbildes, schriftliche Erläuterungen eines Bildes. Bereichsunabhängige Metadaten (Domain-independent metadata): Dieser Metadatentyp sammelt Informationen über das Dokuments unabhängig von den Applikationen oder Arbeitsbereichen der Information. Beispiele: C/C++ Syntaxbaum und HTML/SGML Dokumenttypendefinitionen. Bereichsspezifische Metadaten (Domain-specific metadata): Dieser sammelt Informationen über das Dokument abhängig von den Applikationen oder Arbeitsbereichen des Quelldokuments. Beispiel: Bei Flächen und Bevölkerungsdaten von Volkszählungen stellt das Schema der Datenbank bereichsspezifische Metadaten dar. "
"data5_02.txt";"Kashyap unterteilt Metadaten in sechs verschiedene Kategorien. Inhalt-unabhängige Metadaten: Diese Art von Metadaten enthalten Informationen, die vom Inhalt des Dokumentes, mit dem sie assoziiert werden, unabhängig sind. Beispiele solcher Metadaten sind Location oder auch modification date. Inhalt-abhängige Metadaten: Hier handelt es sich um das Gegenteil der zuvor besprochenen Metadaten. Diese sind abhängig vom Inhalt des Dokumentes, mit dem sie assoziiert werden (z.B. Größe einer Datei, maximale Anzahl der Farben, etc.) Inhaltsabhängige Metadaten werden des Weiteren wie gefolgt unterteilt. Direkt Inhaltsbasierende Metadaten: Wie der Name bereits andeutet, basieren bei dieser Kategorie die Metadaten direkt auf dem Inhalt des Dokumentes. Inhalt beschreibende Metadaten: dieser Typus von Metadaten beschreibt den Inhalt eines Dokumentes ohne jedoch die direkte Verwendung. Die Metadaten beinhalten oft die Nutzung von Wissen oder menschlicher Wahrnehmung bzw. Erkenntnis. Ein Beispiel hierfür ist das Andeuten eines Duftes von einem Bild von einer Blume. Bereichsunabhängige Metadaten: Diese Metadaten beinhalten Informationen einer Datei unabhängig von der Anwendung oder des Fachgebietes (subject domain) der Information, so z.B. der C/C++ Syntaxbaum. Bereichsspezifische Metadaten: Metadaten von dieser Typ werden in einer Art und Weise beschrieben, die hinsichtlich der Information Anwendungs- und Fachbereichsspezifisch sind. Das Vokabular spielt in diesem Fall eine wichtige Rolle, da die Begriffe in einer fachspezifischen Weise gewählt werden müssen. Beispiele hierfür sind unter anderem Fachspezifische Ontologien.  "
"data5_03.txt";"Metadaten werden oft definiert als Daten über Daten. Das Kriterium das Kashyap wählt um Metadaten zu klassifiziert ist das Ausmaß in welchem sie den Inhalt des Informationsartifakts erfassen können. Er unterscheidet zwischen inhaltsunabhängige Metadaten (Content-independent metadata) und inhaltsabhängige Metadaten (Content-dependent metadata). Die erste Kategorie ist ein Datentyp, der Informationen zusammenfasst die unabhängig vom Inhalt sind. Die zweite Kategorie hingegen ist ein Metadatentyp, welcher vom Inhalt abhängt. Die Kategorie der inhaltabhängigen Metadaten werden in sich wiederum in vier Untergruppen unterteilt. Erstens direkt inhaltsabhängige Metadaten (direkt content-based metadata), welche direkt vom Inhalt abhängen. Zweitens inhaltsbeschreibende Metadaten (Content-descriptive metadata), welche den Inhalt ohne den direkten Nutzen daraus beschreiben, und beinhaltet den Gebrauch von Wissen oder menschlichen Sichtweisen und Erkenntnissen. Die dritte Untergruppe bilden die bereichsunabhängige Metadaten (Domain-independent metadata), welche Information über das Dokuments erfassen unabhängig von den Anwendung oder dem Arbeitsbereichen der Information. Schließlich die letzte Gruppe bilden die bereichsspezifische Metadaten (Domain-specific metadata). Sie erfassen Informationen über das Dokument abhängig von den Applikationen oder Arbeitsbereichen des Quelldokuments. "
"data5_04.txt";"Kashyap hat in dem Artikel Metadaten, also Daten über Daten, durch das Ausmaß des Informationsgehalts über die zugrunde liegenden Daten klassifiziert. Durch die Unterscheidung anhand des Grades der Abstraktion, die Teilung in Informationen über den Wissensbereich und anwendungsspezifische Informationen gelangt Kashyap zu der Einteilung in folgende 6 Klassifikationen. Metadaten, die nicht im direkten Zusammenhang  mit dem Dokument stehen, z.B. Änderungsdatum oder Ablageort, bezeichnet er als content-independent metadata, im Gegensatz zu den content-dependent metadata, die Inhalt und Struktur des Dokuments beschreiben, wie die Größe der Datei oder die Zeilenanzahl eines Bildes. Diesen Bereich teilt Kashyap weiter auf in direct content-based metadata, welche die den Inhalten zugrunde liegende Struktur beschreibt, z.B. Verweise oder Indizes, und in content descriptive Metadata, welche die Inhalte beschreiben, ohne Referent auf Ihren Nutzen zu nehmen, z.B. den Duft einer abgebildeten Blume. Zuletzt unterscheidet er zwischen domain-independent metadata, Informationen über Daten unabhängig von verwendeten Anwendungsprogramm oder Umgebung und domain-spezific Metadata, die eben die speziellen Anwendungen beschreiben, z.B. das Datenbankschema. "
"data5_05.txt";"Metadaten sind Daten  also Informationen  über Daten; zum Beispiel über deren Speicherung, Verwendung oder Verwaltung. Metadaten fassen auch Informationen über Daten zusammen. Das Kriterium zur Klassifikation von Metadaten nach Kashyap ist das Ausmaß mit dem man deren Informationsinhalt in anderen Typen von Medien sinnvoll darstellen kann. Die Klassifikation von Metadaten nach Kashyap. Inhaltsunabhängige Metadaten: diese Art von Metadaten sagen nichts über den Inhalt von Daten aus, sondern vielmehr über die Speicherart oder -ort oder das Datum der letzten Änderung. Metadaten, die sich auf den Inhalt beziehen: derartige Metadaten sind abhängig vom assoziierten Inhalt. Zum Beispiel die Größe eines Word-Dokuments, die Anzahl der im Dokument enthaltenen Farben, die dort benutzte Auswahl der Zeilen oder Spalten, etc. Die inhaltsabhängigen Metadaten unterteilen sich in. Direkt inhaltsbasierte Metadaten: diese Metadaten sind direkt vom Inhalt aus Dateien abhängig. Zum Beispiel ein Indizes in Volltext-Version eines bestimmten Dokuments. Inhaltsbeschreibende Metadaten: derartige Metadaten beschreiben den Inhalt einer Datei ohne ihre direkte Verwendung oder Benützung anzugeben. Es geht um Wissen, Begriffe und Erkenntnisse. Zum Beispiel ein textueller Vermerk zur Beschreibung des Inhalts eines Bildes. Bereichsunabhängige Metadaten: sie beinhalten Informationen unabhängig vom Themenbereich oder Applikation. Bereichsspezifische Metadaten: das sind applikationsspezifische Metadaten. Das Vokabular muss hier beachtet werden, es muss in einer bereichsspezifischen bzw inhaltsspezifischen Art  gewählt werden. Zum Beispiel kann das Relief bzw die Struktur einer Datenbank beschrieben werden. "
"data5_06.txt";"Wie bereits im vorigen abstract / essay beschrieben besteht die Notwendigkeit nach der Interoperabilität von Informationssystemen. Hauptbestandteil eines jeden IS sind Datenbanken die mit Management Systemen verwaltbar sind, die sich untereinander durch die Struktur, die Abhängigkeit und die DB-Sprache unterscheiden. Grundlage dieser IS sind neben Struktur der zu verwaltenden Daten deren Repräsentation und auch die Art, Eigenschaft und Inhalt der in einer Datei enthaltenen Daten. In Hinblick auf die Interoperabilität unterscheidet Kashyap zwischen Dateiinhalt und Dateibeschreibung. Letztere werden von ihm als Metadaten bezeichnet, die Auskunft über die enthaltenden Daten selbst darstellen, z.B. wie diese verwaltet werden oder Information für den semantischen Gebrauch. Diese Einteilung hat zwei Vorteile. Erstens wird durch die zusätzliche Information über repräsentative Details wie das Format und die Datenorganisation verhindert, dass es zu einer Informationsüberladung kommt, die sich bei der Zusammenarbeit von Datenbanken als störend erweist. Zweitens wird durch die Metadaten ermöglicht, dass die Datei durchsucht wird, ohne daß diese geöffnet werden muss. Kashyap spricht in diesem Zusammenhang von Inhalt-abhängigen und Inhalts-unabhängigen Metadaten. Unabhängige Metadaten geben Auskunft über den physischen Ort der Speicherung oder Zeitpunkt der Dateiaktualisierung. Diese Daten sind für die Verfügbarkeitsabfrage und die Aktualität von Relevanz. Inhalts-abhängige Metadaten, wie Dateigröße, Farbtiefe, Anzahl der Reihen bzw. Spalten eines Bildes, können als Suchattribute verwendet werden und werden wiederum wie folgt unterteilt. Direkt Inhalts-basierende Metadaten: Hierzu zählen Index bzw. Inhaltsverzeichnis eines Textes. Inhalt beschreibende Metadaten: Gemeint sind Assoziationen bzw. Stichwörter zum Inhalt wie zum Bsp. die Beschreibung eines Bildes. Herkunftsunabhängige Metadaten: Zum Bsp. die Information die in einer Programmiersprache enthalten sind (head,). Herkunftsspezifische Metadaten: Erläutern den Zusammenhang von im Text verwendeten Vokabeln. Zum Bsp. Information über das Herkunftsland oder auch die Ontologie der Information. Je nachdem mit welchen Metadaten ich suche, unterscheidet sich das Ergebnis. (Stichwort/Inhalt/Attribut) "
"data5_07.txt";"Metadaten sind Teil jeder Informationsverwaltung und Wissenssicherung - somit sind Metadaten auch relevant für die Indizierung von Content, Enterprise Information Portals und die Informationssuche. Metadaten definiert man als Daten von Daten, die verschiedene Eigenschaften von Datensätzen beschreiben und den inhaltlichen Kontext herstellen. Sie gelten als Erweiterung des Konzepts in strukturierten Datenbanken und beschreiben den Informationskontext individueller Datenbanken. Kashyap klassifiziert Metadaten nach dem Grad der erfolgreichen Erfassung von Inhalten von Dokumenten. Durch diese Aufteilung erhält Kashyap 6 verschiedene Arten von Metadaten. Die erste Datenart bezeichnet man als content-independent Metadaten. Dieser Typ erfasst Informationen die nicht vom Inhalt des Dokumentes abhängen wie der Standort des Dokumentes oder das Datum des Dokumentes. Eine weitere Klassifikation sind die content-dependent Metadaten. Dieser Typ gibt Informationen die vom Inhalt des Dokumentes abhängen, wieder. Ein Beispiel wäre hier die Größe des Dokumentes, die Anzahl der Zeilen oder die Maximale Anzahl an Farben. Weitere Metadaten, genannt direct content-based Metadaten, basieren direkt auf den Inhalten des Dokumentes wie die Volltext-Indizes des Textes, die inverten Bäume und die  Vektoren des Dokumentes. In der Art der content-descriptive Metadaten werden Inhalte eines Assets beschrieben, ohne ihren direkten Zusammenhang. Dies beinhaltet den Gebrauch von Grundkenntnissen, oder die menschliche Wahrnehmung wie textbasierte Kommentare, die Inhalte eines Bildes beschreiben. Der Typ der domain-independent Metadaten erfasst die Information eines Dokumentes unabhängig von der Applikation oder des jeweiligen Themas wie C/C++ parse trees oder HTML/SGML Dokument extensions. Die letzte Klassifikation, die domain-specific Metadaten beziehen sich direkt auf die Applikation oder das jeweilige Thema. Vokabulare Inhalte werden in diesem Fall sehr wichtig als Beispiel sei hier die Flächendeckung der GIS domain erwähnt. "
"data5_08.txt";"Kashyap versucht Metadaten nach ihrer Aussagekraft über den Inhalt einer Datenquelle zu kategorisieren. Hierbei unterteilt er Metadaten, die Aussagen über die Formatierung und Aufbereitung von Daten treffen und Metadaten, die näher auf den Informationsgehalt und den Wissensgehalt von Daten eingehen. Detaillierter betrachtet unterteilt er die Kategorien in. Vom Inhalt unabhängige Metadaten: Beispiele hierfür sind Ort, Erstellungsdatum oder Änderungsdatum einer Datei. Vom Inhalt abhängige Metadaten: Vom Inhalt abhängige Informationen sind zum Beispiel Größe, Auflösung oder Tabellengröße. Metadaten, die direkt inhaltsbasiert sind: Hier wird direkt auf den Inhalt einer Datei Bezug genommen, zum Beispiel mittels Textindex und dergleichen. Inhaltsbeschreibende Metadaten: Anders als bei den inhaltsbasierten Metadaten wird hierfür meist menschliches Wissen benötigt. Ein Beispiel hierfür ist die Beschreibung eines Bildes. Domain-unabhängige Metadaten. Domain-abhängige Metadaten. "
"data5_09.txt";"Metadaten werden üblicherweise als die Daten über die Daten beschrieben. Man kann Metadaten besser als eine Ausweitung des Konzeptes  für strukturierte Datenbanken beschreiben. Metadaten sind eine Zusammenfassung der individuellen, lokalen Datenbanken. Die Klassifizierung von Metadaten nach Kashyap gliedert sich in einzelne Kategorien. Inhaltsunabhängige Metadaten sind nicht an die Informationsgewinne gebunden, mit denen sie verglichen werden. Das Gegenteil davon sind inhaltsabhängige Metadaten, wie z.B. die Größe eines Dokuments oder die maximale Anzahl der Farben in einem Bild. Inhaltsabhängige Metadaten kann man weiter unterteilen in direkten (basiert direkt am Inhalt der Informationsgewinnung), Inhaltsdeskriptiven (beschreibt Inhalt der Informationsgewinnung ohne direkte Auswertung), Besitz- unabhängigen (fängt Informationen ein, unabhängig davon ob es Verwendung findet oder nicht) und bestimmten Besitz- Metadaten (für die gezielte Verwendung). Metadaten werden dann errechnet, wenn diese gebraucht werden. "
"data5_10.txt";"Metadaten sind definiert als Daten über Daten. Die Kriterien zur Klassifikation werden durch das Ausmaß des Informationsinhaltes in verschiedensten Medientypen repräsentiert. Dies können inhaltsunabhängige Metadaten sein, d.h. diese Daten enthalten Informationen, die nicht mit dem Dateninhalt verknüpft sind. (z.B.: Ort, Änderungsdatum eines Dokuments, etc.). Inhaltsabhängige Metadaten sind vom Inhalt abhängig, z.B. die Größe einer Datei, Spalten- und  Zeilenanzahl eines Bildes, Farbenanzahl, etc.. Diese können weiter in folgende Kategorien unterschieden werden. Direkt-Inhaltsbasierend, d.h. direkt auf den Dokumenteninhalt basierend, z.B.: Volltextindizes. Inhaltsbeschreibende Metadaten, diese Daten beschreiben den Inhalt einer Datei ohne diesen direkt zu verwenden, z.B. Beschreibung des Duftes einer Blume, die sich auf der Bilddatei befindet. Domain-unabhängige Metadaten enthalten Informationen über die Datei unabhängig in welchem Anwendungsprogramm oder Umgebung die Information verwendet wird. Domain-spezifische Metadaten enthalten Informationen über Daten für spezielle Anwendungen bzw. Umgebungen, z.B. das Datenbankschema. Alle Metadaten können entweder vorberechnet und abgespeichert sein oder erst zur Laufzeit generiert werden (z.B. bei Abfrageroutinen). "
"data5_12.txt";"Kashyap klassifiziert Metadaten nach dem Ausmaß wie erfolgreich diese den Inhalt  Daten und Information  der Informations-/Datenbasis bei multimedialer Verwendung beschreiben können. Hierbei ist der Grad der Abstraktion des Inhaltes ein einflussreicher Faktor. Nach Kashyap können Metadaten zunächst content-independent und dependent sein. Im ersten Fall besteht keine Verbindung zwischen der Information und dem Inhalt selbst (Bsp: Änderungsdatum, etc.), wogegen dependent metadata von dem Inhalt den sie beschreiben abhängen (Bsp: Dokumentengröße, etc.). Eine weitere Kategorisierung sind Direct content-based und content-descriptive Metadaten. Erstere hängen beispielsweise als Volltext Indizes direkt von der Datengrundlage ab. Im zweiten Fall beschreiben die Metadaten zwar den Inhalt, werden aber nicht direkt verwendet (Bsp: die Beschreibung des Duftes eines Bildes, das eine Blume enthält). Die Verwendung dieser Metadaten setzt spezifisches Wissen voraus. Eine weitere Kategorisierung erfolgt in Domain-independent und Domain-specific Metadaten. Die Unabhängigkeit des ersten Typs wird durch die Isolierung der Information von der Applikation erreicht. Die Zweite wird in einer für eine Applikation typischen Form beschrieben und setzt somit auch die Kenntnis des entsprechenden Vokabulars voraus. "
"data5_13.txt";"Unter Metadaten versteht man  Daten über Daten welche den Dateninhalt anhand eines bestimmten Vokabulars beschreiben (Semantik!!). Laut Kashyap werden die Klassifikationen von Metadaten wie folgt definiert. Inhaltsunabhängige Metadaten: Diese Art von Metadaten beinhalten Informationen welche nicht vom Inhalt des verfolgten bzw. verknüpften Ziels/Gewinn abhängen. Beispiele dieser Metadaten wären Location, Modifikationsdatum eines Dokuments oder aber Daten von Sensoren mit welchen man photografische Bilder aufnehmen kann. Trotz dieser Unabhängigkeit dem Kontext gegenüber, werden diese Metadaten als nützlich empfunden um die physischen Locations und deren Aktualität ausfindig zu machen. Inhaltsabhängige Metadaten: Folgende Metadaten sind vom Inhalt her stark vom erreichbaren Ziel abhängig. Beispiele dazu wären die Größe eines Dokuments, die Anzahl der unterschiedlichen Farbmöglichkeiten, die Reihen der Zeilen, sowie die Anzahl der Spalten. Inhaltsabhängige Metadaten können wiederum unterteilt werden in. Direkt-Inhaltsabhängige-Metadaten; direkt auf den Inhalt des Ziels gestützt. Inhaltsbeschreibende Metadaten; beschreibt den Inhalt des unabhängig vom endgültigem Gebrauch. Domänenunabhängige Metadaten; erfassen präsente Informationen unabhängig von deren Anwendung. Domänenspezifizierte Metadaten; erfassen präsente Informationen abhängig von deren Anwendung. Alles in allem können Metadaten schon im vorhinein berechnet werden und eventuell in Datenbank gespeichert werden, der die Berechnung erfolgt erst bei einer möglichen Nutzung bzw. einem bevorstehenden Gebrauch. "
"data5_14.txt";"Metadaten werden meistens als Daten über Daten definiert. Der Grad der Abstraktion, auf dem der Inhalt der Werte gefangen genommen wird, ist sehr wichtig. Das Kriterium von Kashyap, das wir verwenden, um Metadaten zu klassifizieren, wird hier erklärt. Inhalt-unabhängige Metadaten: Dieses Typus nimmt Informationen ein, die nicht vom Inhalt des Wertes abhängen, mit dem sie verbunden sind. Inhalt-abhängiges Metadaten: Diese Art hängt vom Inhalt des Wertes ab, mit dem sie verbunden ist. Diese Metadaten können weiters unterteilt werden. Direkt auf Inhalt basierte Metadaten: Diese Art basiert direkt auf dem Inhalt eines Wertes. Inhalt-beschreibende Metadaten: Dieses Typus beschreibt den Inhalt eines Wertes ohne ihre direkte Anwendung. Sie bezieht häufig Nutzung von Wissen oder menschliche Vorstellung beziehungsweise das Erkennen mit ein. Domain-unabhängige Metadaten: Diese Art fängt die Informationen ein, die im Dokument unabhängig von der Anwendung oder von dem Themenbereich der Informationen vorhanden sind. Domain-spezifische Metadaten: Diese Art ist in einem Modus spezifisch für die Anwendung oder für das Themenbereich der Informationen beschrieben. Ausgaben des Wortschatzes werden in diesem Fall sehr wichtig, während die Bezeichnungen in einer Domain-spezifischen Weise gewählt werden müssen. "
"data5_15.txt";"Kashyap teilt Metadaten (grob: Daten über Daten) nach den folgenden Kategorien. Content-independent metadata: Speichert vom Inhalt des Dokuments unabhängige Information, wie zB die Speicheradresse einer Datei oder das Datum der letzten Änderung einer Datei. Content-dependent metadata: Speichert vom Inhalt des Dokuments abhängige Information, wie zB die Grösse einer Datei. Content-dependent metadata kann weiter unterteilt werden in. Direct content-based metadata basiert direkt auf dem Inhalt des Dokuments, wie zB ein Index. Content-descriptive metadata beschreibt den Inhalt des Dokuments, ohne dieses direkt zu verwenden, wie zB die Beschreibung eines Bildes durch Worte. Domain-independent metadata: Speichert Information, die vom Inhalt des Dokuments und seiner Anwendung unabhängig ist, wie zB HTML document type definitions. Domain-specific metadata: Speichert Information in einer Art, die vom Inhalt des 	Dokuments und seiner Anwendung abhängt, wie zB ein database schema. Es ist weiters zu erwähnen dass Metadaten nicht nur precomputed und gespeichert werden können. Metadaten können auch erst bei Bedarf computed werden. In diesem Fall werden die Metadaten durch die Methode ihrer Erstellung repräsentiert. "
"data5_16.txt";"Inhaltsunabhängige Metadaten: Diese Art von Metadaten beziehen sich auf Informationen, welche nichts mit dem Inhalt des Dokumentes, das sie beschreiben, zu tun haben. Diese Daten enthalten keine Informationen über den Inhalt, bestimmen aber die eindeutige Identifikation des Dokumentes, um zu prüfen, ob die enthaltenen Informationen aktuell sind. Beispiele: Ort, Modifikationsdatum eines  Dokumentes, Dokumentname, physischer Ort, Verzeichnisstruktur. Inhaltsabhängige Metadaten: welche beziehen sich auf den Inhalt des Dokumentes bzw. der Information. Beispiele Größe des Dokumentes, Maximale Zahl von Farben, maximale Anzahl der Farben, Reihen und Spalten eines Bildes. Inhaltsabhängige Metadaten können wie folgt eingeteilt werden. Direkt den Inhalt beschreibenden Daten: Diese Art von Metadaten beziehen sich direkt auf dem Inhalt eines Dokumentes. Beispiel: Volltexthinweise, welche sich auf das Dokument beziehen. Inhaltbeschreibende Metadaten: Als inhaltsbeschreibende Metadaten werden Daten bezeichnet, die den Inhalt eines Dokumentes beschreiben, aber nicht direkt im Dokument selbst enthalten sind. Oft beinhaltet  diese Art von Metadaten assoziative Informationen, welche mittels Nutzen des Wissens bzw. durch menschliche Empfindungen entstehen. Beispiel: die Bezeichnung des Duftes einer Blume nach der Betrachtung ihres Bildes. Domänunabhängige Metadaten: diese Art von Metadaten umfasst Informationen, welche im Dokument beinhaltet sind und welche zur Interpretation der Daten Verwendung finden. Beispiele: C/C++ Parse-Trees oder HTML/SGML Dokumentartdefinitionen. Domainspezifische Metadaten (Inhaltsmetadaten):  dieser Typ sind in einer Art beschrieben, welche spezifisch für die Anwendung und Fachbereich der Information ist. Als Beispiel dazu könnte etwa eine Verschlagwortung Mithilfe eines Thesaurus, kontextabhängige Schlüsselwörter etc. nennen."
"data5_17.txt";"Die Kriterien, wie Metadaten zu klassifizieren sind, haben Kashyap et al. 1995 im Buch Metadata for building the MultiMedia Patch Quilt genauer beschrieben. So lassen sich Rückschlüsse ziehen in welchem Ausmaß Metadaten erfolgreich die zugrunde liegenden Informationen beschreiben. Ein wesentlicher Punkt ist der Grad der Abstraktion. Um den semantischen Inhalt von Metadaten herauszufiltern ist es wichtig anwendungs- und/oder bereichsspezifische Informationen zu verwenden. Metadaten haben 2 wesentliche Vorteile: Einerseits erlauben sie die Abstraktion von wichtigen Details, wie zB Format oder Datenorganisation, und halten Informationen über die zugrunde liegenden Daten, ohne zu sehr zu spezifizieren, fest. Andererseits ermöglichen Metadaten die Darstellung von Bereichswissen welches die zugrunde liegenden Daten beschreibt. Dies hilft den Informationsüberfluss zu minimieren. Kashyap et al. definieren folgende 6 Klassifikationen. Content-independent metadata sind Metadaten die nicht im direkten Zusammenhang mit dem Dokument stehen (zB: Datum des Dokuments, Ablageort, usw.). Content-dependent metadata hingegen beschreiben die Inhalte respektive Struktur des Dokuments (zB: Größe des Dokuments, Anzahl der Spalten, usw.). Dieser Bereich kann noch weiter aufgegliedert werden in erstens Direct content-based metadata. Sie beschreiben Strukturen denen die Inhalte zu Grunde liegen (zB: Indizes, Verweise, usw.). Zweitens Content-desciptive metadata. Es werden die Inhalte beschrieben ohne genaue Referenz auf Ihren Nutzen (zB: Beschreibung des Duftes einer Blume auf einem Bild). Domain-independent metadata beschreibt Informationen im Dokument unabhängig von Anwendung oder Sparte (zB: document type definitions). Die letzte Untergruppe ist Domain-specific metadata. Diese Metadaten beschreiben mit bereichsspezifischem Vokabular die Anwendung und/oder Sparte des Dokuments (zB: Flächenwidmungsinformationen in GEO Informationssystemen). "
"data5_18.txt";"Metadaten werden als Daten über Daten beschrieben. Sie gelten als Erweiterung des Konzepts in strukturierten Datenbanken und beschreiben den Informationskontext individueller Datenbanken.  Sie können beschreibend sein oder die Zusammenfassung des Inhalts der Datenbank. Kashyap klassifiziert Metadaten nach dem Grad der erfolgreichen Erfassung von Dokumenteninhalten. Dadurch kann eine Aufgliederung wie folgt durchgeführt werden, die jedoch nur ein Beispiel unter vielen ist. Inhalt-unabhängige Metadaten: Dieser Typ von Metadaten erfasst Informationen, die nicht vom Inhalt des Dokuments abhängen, zB Stelle des Dokuments, Änderungsdatum des Dokuments. Inhalt-abhängige Metadaten: Dieser Typ erfasst Informationen, die vom Inhalt des Dokuments abhängen, zB Grösse des Dokuments, Anzahl der Zeilen und Reihen,  Anzahl der Farben. Direkt Inhalt-basierte Metadaten: Diese Metadaten basieren direkt auf den Inhalten des Dokuments, zB Volltext-Indizes basierend auf dem Text des Dokuments, seitenverkehrte Bäume und Vektoren des Dokuments. Inhalt-beschreibende Metadaten: Hier werden Inhalte eines Postens beschrieben, ohne ihre direkte Benützung notwendig zu machen. Es wird Wissen vorausgesetzt oder die menschliche Wahrnehmung, zB textbasierte Kommentare, die die Inhalte eines Bildes beschreiben. Domain-unabhängige Metadaten: Dieser Typ von Metadaten erfasst die Information eines Dokuments unabhängig von der Applikation bzw. des jeweiligen Themas, zB C/C++ parse trees, HTML/SGML Dokumentendefinitionen. Domain-spezifische Metadaten: Metadaten dieses Typs werden beschrieben in einer spezifischen Art der Applikation. Das Vokabular ist in diesem Fall sehr wichtig, zB Flächendeckung der GIS Domain. "
"data5_20.txt";"Als Metadaten bezeichnet man Daten über Daten. Kayshyap unterscheidet dabei folgende Klassen von Metadaten. Content-independent metadata: beinhaltet Information, die unabhängig vom Inhalt der Daten sind; ein Beispiel dafür wäre das Änderungsdatum oder der Speicherort. Content-dependent metadata: beinhaltet Information, die abhängig vom Inhalt der Daten ist; beispielsweise die Größe des Dokuments. Direct content-based metadata: direkt abhängig vom Inhalt, z.B. ein textbasierender Index. Content-descriptive metadata: beschreibt den Inhalt ohne direkte Nutzung; z.B. wird der Duft einer Blume in einem Bild angezeigt. Domain-independent metadata: enthält Information über das Dokument, unabhängig von der Anwendung; z. B. eine HTML Definition. Domain-specific metadata: beschreiben eine spezielle Art der Domain. Die Auswahl eines Vokabels ist sehr wichtig, da es Rückschlüsse auf die Domain geben soll. Metadaten können entweder vorerstellt werden und dann abgelegt werden oder sie werden dann erzeugt, wenn sie gebraucht werden."
"data5_21.txt";"Die Klassifikation von Metadaten nach Kashyap ist wie folgendes. Inhalt-unabhängige Metadaten  erfassen Informationen, die nicht vom Inhalt der dazugehörigen Anlagen abhängt. Beispiele sind Aufstellung, Modifizierung des Datums eines Dokumentes und der Art  des Aufnehmers für ein fotographisches Bild.  Es gibt keinen Informationsgehalt, der durch diese Metadaten erfasst wird. Aber diese konnten noch nützlich für Wiederherstellung der Anlagen und für die Überprüfung der Informationsaktualität sein. Inhalt-abhängiges Metadaten hängen vom Inhalt der Anlagen ab, auf den sie sich bezieht, z. B Größe eines Dokumentes, Höchstzahl von Farben, Zahl von Reihen, Spaltenzahl eines Bildes. Inhalt-abhängige Metadaten können weiter unterteilt werden  in. Direkt Inhalt-abhängig basierendes  Metadaten   basieren direkt auf dem Inhalt einer Anlage.  Beispiele sind der auf Volltextindex basierende Dokumententext, umgekehrte Baum- und Dokumentvektoren. Inhalt -beschreibende Metadaten  beschreiben den Inhalt einer Anlage ohne ihre direkte Anwendung.  Sie ist oft  für Verwendung von Wissen oder menschlicher Vorstellung oder Erkennen eingesetzt, z. B.  Bedeutung des Duftes von einem  Blumenbild.  Ein anderes Beispiel ist die Textkommentare, die den Inhalt eines Bildes beschreiben. Bereich-unabhängiges Metadaten erfassen die Informationen, die im Dokument vorhanden und  vom Anwendung - oder Themenbereich der Informationen unabhängig sind, z.B. die C/C++ Syntaxbaum und Typendefinition von HTML-/SGML Dokumenten. Bereich-spezifisches Metadaten sind in gewissem Sinne spezifisch zum Anwendung- oder Themenbereich der Informationen beschrieben.  Ausgaben des Wortschatzes sind in diesem Fall sehr wichtig, wie die Bezeichnungen in einer bereichsspezifischen Weise ausgewählt werden müssen, z.B. Geländerrelief, Landabdeckung vom GIS  Bereich, Bereich und Bevölkerung vom Zählungsbereich.  Im Fall der strukturierten Daten ist das Datenbankschema ein Beispiel solchen Metadaten.  Ein anderes interessantes Beispiel ist Bereich-spezifische Ontologie, von denen Bezeichnungen als Wortschatz verwendet werden können, um Metadaten spezifisch zu diesem Bereich zu konstruieren.  "
"data5_22.txt";" Kashyap klassifiziert Metadaten wie folgt. Inhalts-unabhängige Metadaten: Dieser Typ Metadaten erfasst Informationen, die vom Inhalt der Assets, mit denen sie verbunden sind, unabhängig sind, wie z.B. Ort, Modifikationsdatum des Dokuments usw. Diese Art Metadaten erfassen keine content- abhängige Informationen, können aber dennoch für Abfrage- und Wiederherstellungsprozesse sowie zur Kontrolle nützlich sein (z.B. in Bezug auf die Aktualität eines Dokuments o.ä.). Inhalts-abhängige Metadaten: Dieser Typ hangt vom Inhalt der verbundenen Assets ab. Beispiele sind die Grösse eines Dokuments, die maximale Anzahl an Farben, Zeilen und Spalten eines Bildes usw. Inhalts- abhängige Metadaten können folgendermassen weiter untergliedert werden. Direkt auf dem Inhalt basierende Metadaten: Dieser Typ Metadaten basiert direkt auf dem Inhalt eines Assets. Beispiele sind auf dem Text aufgesetzte Voll-Text- Indizierungen oder Dokumenten- Vektoren. Inhalts-beschreibende Metadaten: Dieser Typ beschreibt die Inhalte eines Assets, ohne direkt auf die Verwendung der Inhalte einzugehen. Oftmals bedarf es der Verwendung und Anwendung von Wissen oder menschlicher Perzeption  bzw. Kognition. Ein Beispiel sind Text- Anmerkungen, die den Inhalt eines Bildes beschreiben. Bereichs-unabhängige Metadaten: Dieser Typ Metadaten erfasst  im Dokument inhärente Informationen, die unabhängig von Applikationen oder Subjekt-Domains der Informationen sind, wie z.B. C/C++  Parse-Trees u. HTML/SGML Dokumententyp-Definitionen. Bereichs-spezifische Metadaten: Metadaten dieses Typs sind auf eine spezielle Art und Weise spezifiziert, die verbunden ist mit einer Anwendung oder dem jeweiligen Bereich, aus dem die Information stammt. Daher ist ein adäquates Vokabular von sehr grosser Bedeutung, wie z. B. im Falle bereichs-spezifischer Ontologien   "
"data5_24.txt";"Metadaten werden als Daten von Daten definiert. Sie gelten als Erweiterung des Konzepts in strukturierten Datenbanken und beschreiben den Informationskontext individueller Datenbanken. Kashyap klassifiziert Metadaten nach dem Grad der erfolgreichen Erfassung von Inhalten von Dokumenten. Durch diese Aufteilung erhält Kashyap 6 verschiedene Typen von Metadaten. Content-independent metadata: Dieser Typ erfasst Informationen die nicht vom Inhalt des Dokumentes abhängen. Bsp: Standort des Dokumentes, Datum des Dokumentes. Content-dependent metadata: Dieser Typ erfasst Informationen die vom Inhalt des Dokumentes abhängen. Bsp: Größe des Dokumentes, Anzahl der Zeilen,  Max. Anzahl an Farben. Direct content-based metadata: Diese Metadaten basieren direkt auf den Inhalten des Dokumentes. Bsp: Volltext-Indizes des Textes, inverte Bäume, Vektoren des Dokumentes. Content-descriptive metadata: Hier werden Inhalte eines assets beschrieben, ohne ihren direkten Zusammenhang. Dies beinhaltet den Gebrauch von Grundkenntnissen, oder die menschliche Wahrnehmung. Bsp: Textbasierte Kommentare, die die Inhalte eines Bildes beschreiben. Domain-independent metadata: Dieser Typ von Metadaten erfasst die Information eines Dokumentes unabhängig von der Applikation bzw. des jeweiligen Themas. Bsp: C/C++ parse trees, HTML/SGML Dokument extensions. Domain-specific metadata: Diese Metadaten beziehen sich direkt auf die Applikation oder des jeweiligen Themas. Vokabulare Inhalte werden in diesem Fall sehr wichtig. Bsp: Flächendeckung der GIS domain. "
"data5_25.txt";"Kashyap teilt Metadaten folgendermaßen ein. Kontent unabhängige Metadaten: Dieser Typ von Metadaten beinhaltet Informationen, die nicht von den darunter liegenden Daten abhängen. Beispiel: Speicherort. Diese Daten können dazu genutzt werden, um zu erfahren, ob die Daten aktuell sind oder nicht. Kontent abhängige Metadaten: Diese Metadaten sind vom Inhalt der darunter liegenden Daten abhängig. Beispiel: Dokumentgröße. Kontentabhängige Metadaten können wie folgt weiter unterteilt werden in. Direkt kontentabhängige Metadaten: Dieser Typ von Metadaten ist direkt vom Inhalt der Daten abhängig. Ein Beispiel dafür sind Volltextindizes, die auf dem Text des Dokuments basieren. Kontent beschreibende Metadaten: Diese Metadaten beschreiben den Kontent der Daten. Sie beinhalten oft menschliches Wissen. Ein Beispiel ist die schriftliche Beschreibung eines Gemäldes. Domain unabhängige Metadaten: Die Metadaten beinhalten Informationen, die im Dokument vorhanden sind, unabhängig von dem Subject Domain der Daten. Beispiel: HTML/SGML Dokumententypbeschreibung. Domain spezifische Metadaten: Diese Metadaten beschreiben den Subject Domain der Information. Die Verwendung von richtigem Vokabular ist bei dieser Art von Metadaten sehr wichtig. Beispiel: Datenschema von strukturierten Datenbanken.  "
"data5_26.txt";"Kashyap klassifiziert Metadaten folgendermaßen. Kontent unabhängige Metadaten: Sie beinhalten Informationen, die nicht von den darunter liegenden Daten abhängen. Mit diesen Daten kann die Aktualität herausgefunden werden. Bsp: Änderungsdatum. Kontent abhängige Metadaten: Diese Metadaten sind vom Inhalt der darunter liegenden Daten abhängig. Bsp: Dokumentengröße. Direkt kontentabhängige Metadaten: Sie hängen direkt vom Inhalt der Daten ab. Bsp: Textindizes. Kontentbeschreibende Metadaten: Sie beschreiben den Kontent der Daten. Oft beinhalten sie menschliches Wissen und Intuition. Bsp: Beschreibung eines Bildes. Domain unabhängige Metadaten: Sie beinhalten Informationen, die unabhängig von der Domain in den Daten vorhanden sind. Bsp: pars trees von C/C++. Domain beschreibende Metadaten: Sie beschreiben die Domain, aus der die Daten stammen. Es ist wichtig, die richtige Sprache zu verwenden, da die Informationen domainabhängig sind. Bsp: Datenbankschema von Datenbanken. "
"data6_01.txt";"Latent Semantic Analysis (LSA) ist eine automatische mathematische/statistische Technik um Relationen im Kontext von gebrauchten Wörtern zu extrahieren und abzuleiten. Um dies zu ermöglichen sind mehrere Schritte notwendig. Zuerst wird der Text als Matrix dargestellt. Dabei steht jede Reihe für ein einzelnes Wort und jede Spalte für einen Absatz. Jede Zelle enthält die Häufigkeit mit welchen das Wort vorkommt. Dann wird jede Zellhäufigkeit mit einer Funktion gewichtet. In dieser Funktion sind sowohl die Wortwichtigkeit im jeweiligen Absatz als auch das Ausmaß des Informationsgehaltes zum Gesamtinhalt enthalten. Im dritten Schritt findet eine Zerlegung der Matrix mittels einer Faktorenanalyse statt. Die rechteckige Matrix wird dabei in das Produkt von drei weiteren Matrizen zerlegt. Die erste Matrix repräsentiert die Originalreihe als Vektor der abgeleiteten Faktorwerte. Die zweite beschreibt die Originalspalte als Vektor der abgeleiteten Faktorwerte und die dritte ist eine diagonale Matrix welche die abgeleiteten Werte enthält. Multipliziert man die drei Matrizen so erhält man wieder die Originalmatrix. "
"data6_02.txt";"Im ersten Schritt wird der Text in eine Matrixform umgewandelt, in welcher einer jeden Zeile ein eindeutiges (unique) Wort zugeordnet wird und jede Spalte eine Textpassage beinhaltet. Die Werte in den einzelnen Zellen geben wiederum die Häufigkeit an, mit der das entsprechende Wort der gewählten Zeile in der betreffenden Textpassage der Spalte vorkommt. Als nächstes werden die Zellenwerte transformiert, indem in jeder Zelle die Häufigkeit mit einer Funktion, welche sowohl die Bedeutung des Wortes in der bestimmten Textpassage, als auch den Grad an Information, welche dieser Worttyp im Allgemeinen mitträgt, gewichtet wird. Im nächsten Schritt wendet LSA eine Singular Value Decomposition (SVD) bei der Matrix an. Hier handelt es sich um eine Art der Faktor Analyse, welche - genauer ausgedrückt - eine Spezialform der mathematische Generalisierung darstellt. Die Singular Value Decomposition spaltet nun die ursprüngliche rechteckige Matrix in das Produkt dreier neuen Matrizen auf. Mit Hilfe weiterer statistischer und mathematischer Transformationen kann somit nun jede Textpassage transformiert werden. "
"data6_05.txt";"LSA wird für Textanalysen benutzt. Das Ziel ist, inhaltliche Ähnlichkeiten zwischen zwei Texten zu erkennen. Mit dieser mathematischen/statistischen Methode kann man Rückschlüsse auf den erwarteten Inhalt von Texten ziehen. Diese Methode wir also verwendet um den Inhalt eines langen Texts zu extrahieren um so zu einem inhaltlich vergleichenden Ergebnis zu kommen. Die Schritte, die für diese Inhaltsanalyse durchgeführt werden müssen, sind folgende. Zuerst wird der Text in Matrixform zerlegt bzw aufgezeichnet, wobei jede Zeile für jedes einzelne Wort in ihr steht; jede Spalte steht für einen bestimmten Textteil. Damit kann man die Häufigkeit anzeigen mit der ein Wort in einer Zelle zeilen- oder spaltenweise im Text vorkommt. Durch diese Zellenbildung erfolgt dann eine Transformation. Darin wird zum Beispiel jede Häufigkeit der Wörter funktional gewichtet, d.h. es wird die Bedeutung eines Worts in einer bestimmten Textstelle untersucht, zum anderen untersucht man den Informationsgehalt eines Wortes selbst, diesmal aber ohne Kontextabhängigkeit. Im nächsten Schritt wird SVD (singular value decomposition) zur weiteren Analyse verwendet. Dabei geht die ursprüngliche, rechteckige Matrix in anderen drei Matrizen auf; die ursprüngliche Matrix wird also zerlegt. Die erste beschreibt die original Zeilenwerte, abgeleitet als ein Vektor rechtwinkeliger Faktorenwerte, die zweite beschreibt die original Spaltenwerte und die dritte ist eine diagonale Matrix, die aus der ersten und zweiten gebildet wird. Jede Matrix ist in ihre kleinste Dimension zerlegbar. Daraus läßt sich die Analyse durchführen. "
"data6_06.txt";"Grob wird die LSA in 4 Teilschritte unterteilt. 1 Schritt: Der zu untersuchende Text wird in eine Matrix übertragen. Für jedes Wort ist eine eigene Zeile gedacht, jede Reihe steht für eine Textpassage bzw. einen bestimmten Kontext. Nun wird für jedes Wort die Häufigkeit in die jeweilige Spalte (Passage) eingetragen. 2 Schritt: Nun muss die diese Matrix in eine Einwert-Matrix linear zerlegt werden. Bei dieser Art der Faktoranalyse wird die rechtwinkelige Matrix in 3 Matrixen aufgespalten. Die erste Matrix beschreibt die mit orthogonalen Faktorwerten (Relationen zu den anliegenden Werten) gewichtete/abgeleitete Matrix bezogen auf 2 Verhältnisse in den Reihen. Bei der zweiten Matrix wird dasselbe mit den Spalten gemacht. Nun haben alle Wörter einen Wert egal ob sie tatsächlich im Satz enthalten waren oder nicht. Die dritte Matrix ist eine Diagonalmatrix mit deren Hilfe man die ursprünglichen Werte der ersten beiden Matrixen wieder rekonstruieren kann. 3 Schritt: Hier wird die ursprüngliche 2 Dimensionen Matrix wieder hergestellt, jedoch nur mit Hilfe der Vektorenelemente zweier Referenzzeilen. Auch wenn also ursprünglich ein Wort in einer Zeile gar nicht vorgekommen ist, hat die Zelle einen Wert, der stark davon abhängt, in welchem Zusammenhang er mit den anliegenden Zellen stehen mag. Umso höher der Wert umso wichtiger scheint dessen Bedeutung im Kontext zu sein. Dieser Faktorwert kann jedoch nur eine Schätzung sein, wie oft ein Wort X im Zusammenhang Y vorkommt. 4 Schritt: Damit diese Zahlen also eine positive oder negative Korrelationen zwischen den einzelnen Zeilen des Textes mit den anderen Zeilen ausdrücken, muss man diese einmal anhand der Rohdaten berechnen und einmal mit den Vektoren der 2 dimensionalen Matrix. "
"data6_07.txt";"Latent Semantik Analysis (LSA) ist ein Verfahren, das zur vollautomatischen Indizierung von Texten und zum Textretrieval entwickelt wurde. Andere Verfahren funktionieren entweder sehr einfach (simples Wortmatchen) und liefern dementsprechend ungenaue Ergebnisse. Linguistische Verfahren sind zwar anspruchsvoller und versprechen dementsprechend bessere Ergebnisse, verlangen dafür aber oft Handarbeit und hohen rechnerischen Aufwand. Bekannteste Probleme sind Synonymen und Homographen, außerdem sind Wortabhängigkeiten ein Problem. Im Folgenden werden der Formalismus dargestellt, wie man die Ähnlichkeit von zwei Texten untersuchen kann. Die Lösung ist es, Dokumente und Worte werden als Vektoren im gleichen multidimensionalen Vektorraum darzustellen. Über einen Winkelvergleich der Vektoren untereinander kann die Ähnlichkeit festgestellt werden. Der erste Schritt ist, den Text als eine Matrix darzustellen, in der jede Reihe für ein einzelnes Wort steht und jede Spalte für eine Textpassage. Jede Zelle zeigt die Häufigkeit an, mit der das Wort jeder Reihe in der Textpassage erscheint. Danach werden die Zelleinträge umgeformt. Ein wichtiger Teil der Analyse ist die Vorverarbeitung der Daten. Dabei werden die Daten in eine Rohform gebracht, nämlich werden die Wörter je nach Kontext in der Matrix umgewandelt. Zuerst wird die Häufigkeit der Wörter festgehalten. Danach wird die Entropie gemessen. Das Ergebnis dieser Umformung ist, jede Anzahl des Worttyps mit der Wichtigkeit in der Textpassage zu verbinden. Im nächsten Schritt wird die Singular Value Decomposition (SVD) auf die Matrix angewendet. Dies ist eine Art von Faktoranalyse, genauer gesagt die mathematische Generalisierung, eine Art der Faktoranalyse. Bei SVD wird die rechteckige Matrix in drei Matrizen aufgespaltet. Eine Matrix beschreibt die ursprünglichen Reihenentitäten als Vektoren von abgeleiteten Faktorwerten. Eine andere die ursprünglichen Spaltenentitäten in derselben Art. Die dritte ist eine diagonale Matrix, die skalierte Werte beinhaltet, sodass wenn die drei miteinander multipliziert werden, wieder die originale Matrix. "
"data6_08.txt";"Im Text werden 9 Titel miteinander mittels LSA verglichen. Folgende Schritte werden dafür gesetzt. Als erstes wird eine Matrix erstellt, in der die Wort  zu  Wort  Bezüge dargestellt werden. Im nächsten Schritt kommt die singuläre Wertauflösung zum Zug. Hierbei wird die Matrix vom ersten Schritt in drei andere Matrizen aufgeteilt. Das Produkt dieser drei Matrizen ist wiederum die erste Matrix. In zwei dieser Matrizen werden die ursprünglichen Reihenentitäten als Vektoren von den abgeleiteten Werten dargestellt. Die dritte Matrix die aus der Ur-Matrix folgt ist eine diagonale Matrix, die multipliziert mit den anderen zwei Matrizen wiederum die Ur-Matrix ergibt. Bei der Ableitung von der Ur-Matrix kommt es beim LSA-Verfahren jedoch zu Rundungsfehlern. "
"data6_09.txt";"Der Titel LSA (Latent Semantic Analysis) deutet bereits darauf hin, dass es sich um eine Methode handelt, die in der Lage ist, die latente semantische Struktur zwischen Wörtern aufzudecken. Latente Semantik bedeutet verborgene Information. Es ist eine Methode, die durch mathematische/statistische Techniken, sich folgernde, zusammenhangsbezogene Wörter in Textpassagen finden soll. Der erste Schritt ist einen Text in einer Matrix  darzustellen. Hierbei gilt, dass jede einzelne Reihe für ein bestimmtes Wort und jede Spalte für eine Textpassage reserviert ist. Der nächste Schritt ist die Singulärwertzerlegung (SVD). Dabei wird eine rechteckige Matrix, in drei andere Matrizen zerlegt. Dahergehend, dass man viele Wörter in die Matrix miteinbezieht, wird diese auch sehr groß ausfallen. Die erste Matrix beschreibt die Wörter, die zweite die Passagen und die dritte ist eine Diagonalmatrix. Da beim Multiplizieren von Matrizen Produkte der Einträge addiert werden, und die Reihenfolge bei der Addition egal ist, können Zeilen und Spalten der Diagonalmatrix vertauscht werden, solange auch die entsprechenden Spalten von den beiden anderen Matrizen vertauscht werden. Dadurch kann erreicht werden, dass die Werte auf der Diagonalmatrix, welche Singulärwerte heißen, absteigend geordnet sind. Dadurch kommt man zu kleineren Faktoren, die nicht berücksichtigt werden müssen. Durch dieses Verfahren findet eine Annäherung statt, welche man auch als Dimensionsreduktion bezeichnen kann, wobei man hofft, dass die wichtigen Wörter übrigbleiben. Die Methode liefert ein Maß für die Ähnlichkeit von Wörtern. "
"data6_10.txt";"LSA ist eine Methode um semantisch äquivalente, aber unterschiedlich geschriebene Wörter mit Hilfe einer mathematischen Methode zu identifizieren. In einem ersten Schritt wird eine Textmatrix (Dokument/Wort-Matrix) erstellt, welche in den Zeilen jedes der einzelnen Worte  der zu prüfenden Texte enthält und in den Spalten die Textpassage, Dokument bzw. den Kontext. Jede Zelle enthält vorerst die Anzahl (frequency) mit der es in dem entsprechenden zugeordneten Text auftritt. Weiters wird für jedes Wort ein gewichteter Wert berechnet und zwar mit Hilfe einer Funktion, die sowohl die Relevanz des Wortes in dem Dokument als auch den Grad des Informationsgehalts des Wortes im allgemeinen enthält. Als nächster Schritt wird die Singular Value Decomposition (SVD) durchgeführt. Diese Methode ist eine Form der Faktor-Analyse, mit Hilfe derer die Wort/Dokument-Matrix (X) in drei andere Matrizen gespalten wird, nämlich die orthogonalen Matrizen W und P und in die Diagonale S. Eine Matrize beschreibt die Original-Zeileneinträge als Vektoren der orthogonalen Faktorwerte, die zweite die Spalteneinträge auf dieselbe Art und Weise. Die dritte, die Diagonale enthält die Skalenwerte (singular values) die durch Multiplikation wieder die Original-Matrixwerte ergeben. Nach Neuordnung dieser Werte und Umsortierung der ursprünglichen Matrizen wird die ursprüngliche Matrize X in einen geringer dimensionalen Raum durch das Nullsetzen aller Werte außer dem höchsten projeziert. Die Ähnlichkeit zweier Worte wird durch die Position der Wort-Vektoren in der Matrize im reduziert-dimensionalen Raum bestimmt. (z.B.: durch den Winkel zwischen den Vektoren). "
"data6_11.txt";"Formalismus: 1. Den Text in Form einer Matrix darstellen. Zeilen stehen für ein einzelnes Wort. Spalten für eine Texteinheit. Zellen beinhalten die Häufigkeit mit der das Wort in der Texteinheit vorkommt. 2. Häufigkeit wird mit bestimmter Funktion gewichtet. 3. Die erstellte Matrix X wird in drei Faktoren (= drei Matritzen) aufgespalten, und zwar durch eine Operation, die Singular Value Decomposition (SVD) heißt ( X = W0 S0 D0T). Die Matritzen enthalten linear unabhängige Vektoren und ergeben multipliziert miteinander natürlich wieder die Ausgangsmatrix. Für die drei Faktoren gilt. W0 ist die Matrix der Eigenvektoren der quadratischen Matrix Y1 = XXT. D0 ist die Matrix der Eigenvektoren der quadratischen Matrix Y2 = XTX. S0 ist die Matrix der Eigenwerte der Eigenwert-Eigenvektor-Dekomposition. Nun wird noch die Dimensionalität der Matrix reduziert. Angefangen bei den kleinsten Werten in der S0 Matrix "
"data6_12.txt";"LSA ist eine vollautomatische mathematisch-statistische Methode zur Identifizierung semantisch gleichwertiger, aber verschieden geschriebener Wörter. Zunächst wird der zu untersuchende Text als Matrix dargestellt, in der jede Reihe für ein einzigartiges Wort und jede Spalte für eine Textpassage oder den Kontext steht. Jede Zelle enthält nun die Häufigkeit  frequency  eines Wortes einer Reihe mit der es in der durch die Spalten repräsentierten Textpassage vorkommt. In Folge wird die Zellenhäufigkeit mittels einer Funktion gewichtet, die die Relevanz und den Informationsgehalt des Wortes veranschaulicht. Die Wort-Text-Matrix wird in einem weiteren Verfahrensteil mit Hilfe der Singular Value Decomposition (SVD)  Methode, einer Form der Faktor-Analyse, in drei neue Matrizen gespalten. Diese Matrizen enthalten als Vektoren dargestellt die eigentlichen Zeilen-Spalteneinträge und die singular values  die Skalenwerte. Darauf folgend wird die Ausgangsmatrix mit Hilfe des Nullsetzens aller Werte, mit Ausnahme des Höchsten in einen kleiner-dimensionalen Raum projiziert. Vorab werden die Werte noch neu geordnet und neu sortiert. Schließlich lässt die Stellung der Vektoren im kleindimensionalen Raum Rückschlüsse auf die Ähnlichkeit der Ursprungsinhalte zu. "
"data6_13.txt";"LSA ist ein Verfahren, das zur vollautomatischen Indizierung von Texten und zum Text-retrieval entwickelt worden. Um eine solche Indizierung durchzuführen müssen erstmals Dokumente und Worte als Vektoren dargestellt werden. Diese müssen sich allerdings in einem gleichen multidimensionalen Vektorraum befinden. Das Ziel liegt darin semantisch äquivalente, aber unterschiedlich geschriebene Wörter zu identifizieren. Kurz beschrieben kann dieses Verfahren in 3 Schritten durchgeführt werden. Der Zielsetzung, die Eingabe (Texte oder Textphrasen werden in einer einheitlichen Sprache eingegeben) und schlussendlich das Ergebnis: Eine Auflistung von Wörtern die zu einem Begriff semantisch äquivalent sein könnten. Genauer betrachtet werden die Daten, zur Datenmengenreduktion, in einem mathematischen  Verfahren bearbeitet. Dazu werden diese Daten in Form einer Matrix repräsentiert, und durch das System der Singular Value Decomposition (SVD) faktorisiert. Die zentrale Datenstruktur ist also die Matrix wobei Terme hierbei Worte sind, welche in mindestens zwei (bis ca. 1000-2000) Dokumenten vorkommen. Ein Element in dieser Matrix repräsentiert die Häufigkeit eines Terms innerhalb eines Dokuments. Anschließend wird die erstellte Matrix mittels SVD in drei weitere Matrizen mit linear unabhängigen Vektoren aufgespalten. 1) W0: Matrix der Eigenvektoren der quadratischen Matrix XXT. 2) D0:  Matrix der Eigenvektoren der quadratischen Matrix XTX. 3) S0:  Matrix der Eigenwerte der Eigenwert-Eigenvektor-Dekomposition. Die Zeilen und Spalten der Matrix S0 werden so vertauscht, dass die Werte der Größe nach geordnet auf der Mitteldiagonale liegen. Als letzter Schritt folgt die Reduzierung  der Dimensionalität der Matrix S0  auf S (gleichzeitige Reduzierung von Matrix W0 auf W und D0 auf D). Multipliziert man zu guter letzt die drei Matrizen S, W und D miteinander, kann man damit die im Text verborgenen semantischen Strukturen aufdecken.  "
"data6_14.txt";"Der erste Schritt ist, den Text wie eine Matrix darzustellen, in der jede Reihe für ein einzigartiges Wort und jede Spalte für eine Textpassage oder für anderen Kontext stehen. Jede Zelle enthält die Frequenz, mit der das Wort seiner Reihe in der Passage erscheint, die durch seine Spalte kennzeichnet wird. Zunächst werden die Zelleintragungen einer einleitenden Umwandlung unterworfen, in der jede Zelle Frequenz durch eine Funktion gewichtet wird, die sowohl den Wichtigkeit des Wortes in der bestimmten Passage als auch den Grad ausdrückt, für den das Worttypus im Allgemeinen Informationen in dem Diskursbereich trägt. Danach wendet LSA singuläre Wertaufspaltung (SVD) an der Matrix an. Diese SVD ist eine Form der Faktoranalyse. In SVD wird eine rechteckige Matrix in das Produkt von drei anderen Matrizen zerlegt. Eine Teilmatrix beschreibt die ursprünglichen Reihenentitäten als Vektoren der abgeleiteten orthogonalen Werte, eine andere beschreibt die ursprünglichen Spaltenentitäten in gleicher Art und Weise, und die dritte ist eine diagonale Matrix, die solche Skalenwerte enthält, durch die so, wenn die drei Teile matrix-multipliziert sind, die ursprüngliche Matrix wieder rekonstruiert wird. "
"data6_15.txt";"Erster Schritt: Abbildung eines Textes in Form einer Matrix, wobei jede Reihe für ein Wort und jede Spalte für eine Textpassage steht. Jeder Wert (jede Zelle) gibt an, wie oft ein bestimmtes Wort in einer bestimmten Textpassage vorkommt. Zweiter Schritt: Die Werte werden gewichtet. Der Algorithmus beachtet die Wichtigkeit eines bestimmten Wortes in einer bestimmten Textpassage sowie die Wichtigkeit dieses Wortes für dieses Thema im allgemeinen. Dritter Schritt: SVD (Single Value Decomposition): SVD ist die Generalisierung der Faktoranalyse. Eine Matrix wird in drei Matrizen verwandelt, deren Produkt die ursprüngliche Matrix ist. Vierter Schritt: Die Dimensionen werden reduziert, indem Koeffizienten der diagonalen Matrix (siehe Figur 2, Seite 11) gelöscht werden. Fünfter Schritt: Rekonstruktion der Matrix mit reduzierten Dimensionen. "
"data6_17.txt";"Mit Hilfe von LSA kann die Ähnlichkeit 2er Texte gemessen werden. Der zu analysierende Text wird in eine Tabelle übertragen und aufgegliedert. In den Zeilen werden die semantischen Wörter und in den Spalten die exakte Position im Text festgehalten. Nun wird, wie bei vielen Scoring Methoden, ein gewichteter Wert für jedes Wort berechnet. Neben der Gewichtung ist auch die Häufigkeit des Vorkommens im Text in jeder Zelle vermerkt. Durch eine mathematische Formel wird der Grad der Gewichtung berechnet, wobei folgende Punkte relevant sind: die Aussagekraft eines Wortes im Dokument sowie die Aussagekraft des Wortes im Allgemeinen. Mit Hilfe der Singular Value Decomposition wird der Text aufgegliedert und eine Faktor Analyse durchgeführt. Das nun aus 3 Tabellen bestehende Dokument enhält die Tabelle W und P sowie eine Diagonale S. Durch die Multiplikation der Tabellen W und P, der Umsortierung und Neuordnung aller Skalenwerte sowie dem Nullsetzen aller Werte wird nun die Ähnlichkeit auf Grund der Nähe zueinander deutlich. "
"data6_18.txt";"Latent Semantic Analysis (LSA) ist ein Verfahren, das zur automatischen Indizierung von Texten und zum Textretrieval entwickelt wurde. Im Folgenden werden die einzelnen Schritte dargestellt, wie man die Ähnlichkeit von zwei Texten untersuchen kann. Der erste Schritt ist, den Text als eine Matrix darzustellen, in der jede Reihe für ein einzelnes Wort steht und jede Spalte für eine Textpassage. Jede Zelle zeigt die Häufigkeit an, mit der das Wort jeder Reihe in der Textpassage erscheint. Danach werden die Zelleinträge umgeformt. Ein wichtiger Teil der Analyse ist die Vorverarbeitung der Daten. Dabei werden die Daten in eine Rohform gebracht, nämlich werden die Wörter je nach Kontext in der Matrix umgewandelt. Zuerst wird die Häufigkeit der Wörter festgehalten. Danach wird die Entropie (Mass für den Informationsgehalt) gemessen. Das Ergebnis dieser Umformung ist, jede Anzahl des Worttyps mit der Wichtigkeit in der Textpassage zu verbinden. Im nächsten Schritt wird die Singular Value Decomposition (SVD) auf die Matrix angewendet. Dies ist eine Art von Faktoranalyse, genauer gesagt die mathematische Generalisierung, eine Art der Faktoranalyse. Bei SVD wird die rechteckige Matrix in drei Matrizen aufgespalten. Eine Matrix beschreibt die ursprünglichen Reihenentitäten als Vektoren von abgeleiteten Faktorwerten. Eine andere die ursprünglichen Spaltenentitäten in derselben Art. Die dritte ist eine diagonale Matrix, die skalierte Werte beinhaltet, sodass wenn die drei miteinander multipliziert werden, wieder die originale Matrix herauskommt. "
"data6_19.txt";"Zunächst wird aus dem Text eine Matrix gebildet. Jede Zeile steht für ein bestimmtes Wort und jede Spalte steht für eine Textpassage bzw. einen Sinnzusammenhang. Die Zellen beinhalten die Häufigkeit mit der das jeweilige Wort aus der Zeile in der Textpassage der jeweiligen Spalte vorkommt. Danach werden die Zelleinträge einer vorläufigen Transformation unterzogen. Dabei werden die Zellhäufigkeiten mit einer Funktion gewichtet, welche die Wichtigkeit des jeweiligen Wortes in einer bestimmten Passage ausdrückt. Als nächstes wird eine Art von Faktoranalyse durchgeführt. Das Verfahren nennt sich singular value decomposition (SVD). Dabei wird eine rechteckige Matrix in drei andere Matrizen zerlegt. Eine Teilmatrix beschreibt die ursprünglichen Zeileneinträge als Vektoren der abgeleiteten rechtwinkeligen Faktorwerte. Die zweite Teilmatrix erfüllt im Prinzip dieselbe Aufgabe jedoch bezieht sich diese auf die ursprünglichen Spalteneinträge. Die dritte Teilmatrix ist eine diagonale Matrix, welche Skalierungswerte enthält, um beim Multiplizieren der drei Matrizen die ursprüngliche rechteckige Matrix wiederherzustellen. "
"data6_20.txt";"LSA ist ein automatisches, mathematisch-statistisches Verfahren, um die Ähnlichkeit von zwei Texten zu untersuchen. Dafür wird im 1. Schritt der Text als Matrix dargestellt, bei dem jede Zeile für ein einmaliges Wort steht und jede Spalte für eine Textpassage. Jede Zelle beinhaltet die Häufigkeit mit dem ein Wort einer Zeile in der Textpassage vorkommt. Danach werden die Zelleneinträge transformiert und durch eine Funktion gewichtet. Dadurch erhält man eine Angabe, die die Wichtigkeit und den Grad des Informationsgehalts enthält. Als nächstes bringt man ein s.g. SVD, das steht für singular value decomposition, an die Matrix an. Dabei handelt es sich um eine Art der Faktoranalyse. Die rechtwinkelige Matrix wird hierbei das Produkt von 3 anderen Matrizen. Eine Matrix beschreibt dabei die ursprünglichen Zeileneinträge als Vektoren der abgeleiteten orthogonalen Faktorwerte, die Zweite beschreibt die ursprünglichen Spalteneinträge und die Dritte ist eine diagonale Matrix.  "
"data6_21.txt";"Der erste Schritt ist, den Text als Matrix darzustellen, in der jede Reihe für eindeutiges Wort  und jede Spalte für einen Textstelle oder anderen Kontext steht.  Jede Zelle enthält die Frequenz, mit der die Wortreihe in der Stelle der Spalte aufscheint.  Zunächst werden die Zelleneinträge einer einleitenden Transformation unterworfen, in denen jede Zellenfrequenz durch eine Funktion gewichtet wird. Diese drückt  Bedeutung des Wortes in der bestimmten Stelle und den Grad, wie die Wortart die Informationen trägt, aus. Zunächst wendet LSA einzigartige Wertaufspaltung (SVD) an der Matrix an.  Dieses ist eine Form der Faktoranalyse. In SVD wird eine rechteckige Matrix in das Produkt von drei anderen Matrizen zerlegt.  Eine Teilmatrix beschreibt die ursprünglichen Reiheninstanzen als Vektoren vom berechneten orthogonalen Faktorwert. Andere beschreiben die ursprünglichen Spalteinstanzen in der gleichen Art und Weise. Der Dritte ist eine diagonale Matrix, enthält Skalenwerte, sodass wenn die drei Bestandteile Matrix - multipliziert werden,  wird die ursprüngliche Matrix wieder aufgebaut.  "
"data6_22.txt";"Der erste Schritt ist, den Text in die Form einer Matrix überzuleiten, bei der jede Reihe für ein einzelnes Wort und jede Spalte für eine Text- Passage oder anderen Kontext steht. Die mathematischen Operationen, die dem ganzen zugrunde liegen, bestehen aus einer zweiteiligen Transformation. Zuerst wird die Wort-Frequenz (+1) in jeder Zelle logarithmiert. Danach wird der Informationsgehalt (Entropie) mittels der Operation  p log p für alle Daten einer Zeile berechnet und jeder Zell- Eintrag anhand des Zeilen- Entropie- Wertes geteilt. Als nächstes wird die Singular Value Decomposition (SVD), eine Form der Faktor-Analyse, auf die Matrix angewandt.  Bei der SVD wird die Ausgangsmatrix in drei andere Matrizen zerlegt, wobei eine Teil-Matrix die ursprünglichen Zeilen-Entitäten als Vektoren der abgeleiteten orthogonalen Faktor- Werte enthält, eine zweite beschreibt die originalen Spalten- Entitäten auf die gleiche Art und Weise, und die dritte ist eine diagonale Matrix, die derart skalierte Werte enthält, dass bei einer Matrizen-Multiplikation aller drei Teil-Matrizen die ursprüngliche Ausgangs-Matrix wiederhergestellt wird. "
"data6_23.txt";"LSA (Latent Semantic Analysis) ist ein mathematische Technik zum Aufsuchen vom zusammenhängenden Wörtern oder Texten. Der erste Schritt ist, dass der Text in einer Matrix gezeigt wird. In jeder Zeile wird das Wort und in jeder Spalte die Textpassage abgebildet. In jeder Zelle ist die Häufigkeit ersichtlich, wie oft ein Wort in der Textpassage vorkommt. Danach werden die Einträge einer Vorauswahl unterworfen, wobei die Häufigkeiten mit einer Funktion gewichtet wird, die die Wichtigkeit des Wortes in der Passage angibt und wie hoch der Informationsgrad dieses Wortes ist. Im zweiten Schritt wird die Ausgangsmatrix in drei Matrizen aufgespaltet. Dabei werden nicht alle Faktoren der drei Matrizen verwendet. Die verwendeten Faktoren werden durch lineare Kombinationen verbunden. Diese Aufspaltung kann aber nicht fehlerfrei erfolgen. Es kann passieren, dass Wörter mit einer abweichenden Häufigkeit gezeigt werden oder dass Häufigkeiten vorkommen, die vorher noch nicht da waren. Zum Überprüfen, was bei dieser Zerlegung passiert, werden Inter-Korrelationen zwischen den Titel herangezogen. Eine weitere Matrix mit 2 Dimensionen auf Basis der ursprünglichen Matrix bewirkt, dass die Gruppierung der Themen treffender wird. "
"data6_24.txt";"Latent Semantic Anlaysis (LSA) ist eine völlig automatisierte mathematische/statistische Methode um Beziehungen bzw. Verbindungen zwischen Wörtern abzuleiten. LSA verwendet keine Grammatik, semantische Netzwerke, selbst aufgebaute Wörterbücher, sondern verwendet nur Rohtexte, analysiert diese und verwandelt sie in sinnvolle Textpassagen oder Sätze. Nachfolgend wird erläutert, welche Schritte durchgeführt werden müssen, um mit Hilfe von LSA die Ähnlichkeit von zwei Texten zu untersuchen. Als Erstes wird der Text als eine Matrix dargestellt, wobei jede Reihe für ein einzelnes Wort und jede Spalte für eine Textpassage steht. Jede Zelle beinhaltet die Häufigkeit, mit der das Wort jeder Reihe in der Textpassage erscheint. Danach werden die Zelleinträge transformiert, wobei jede Zelle nach 2 Merkmalen in einer Passage gewichtet wird: Wichtigkeit des Wortes, Grad zu welchem der Worttyp, Informationen überträgt. Als nächstes wird die Singular Value Decomposition (SVD) auf die Matrix angewendet. Dies ist eine Art Faktoranalyse. In der SVD wird die rechtwinkelige Matrix in die Produkte drei anderer Matrizen aufgeteilt. Die erste Matrix beschreibt die ursprüngliche Zeile als Vektor abgeleiteter rechtwinkeliger Faktorwerte. Die zweite Matrix beschreibt die ursprüngliche Spalte derselben Art und Weise. Die dritte Matrix ist eine diagonale Matrix die skalierbare Werte beinhaltet. Wenn alle drei Matrizen miteinander multipliziert werden, gelangt man wieder zur ursprünglichen Matrix. "
"data6_25.txt";"Mit Latent Semantic Analyses (LSA) können erwartete Beziehungen von Wort und Textpassagen extrahiert werden. Es handelt sich dabei um ein vollautomatisches mathematisch  statistisches Verfahren. Zunächst wird in eine Matrix umgewandelt, wobei jede Spalte für eine Textpassage steht und jede Zeile für ein Wort. In den Zellen ist die Häufigkeit der Worte eingetragen. Jetzt werden die Inhalte der Zellen gewichtet (mithilfe einer Funktion) und somit festgelegt, wie wichtig und informativ das jeweilige Wort ist. Im nächsten Schritt wird mit der Single value decomposition die Matrix in drei Matrizen zerlegt. Eine Matrize beschreibt die Zeilen, eine die Spalten und eine ist die Diagonalmatrize. Da keine Matrix perfekt zerlegt werden kann, wird auch eine Matrix erzeugt, die die Ausgangsmatrix auf zwei Dimensionen rekonstruiert. Damit wird erreicht, dass sich gleiche Beziehungen anpassen und die Gruppierung wird eindeutiger. "
"data6_26.txt";"Latent Semantic Analyses (LSA) ist ein vollautomatisches mathematisch-statistisches Verfahren, dass erwartete Beziehungen von Wort oder Textpassagen extrahiert. Im ersten Schritt wird der Text als Matrix dargestellt. Jede Zeile steht für ein Wort und jede Spalte für eine Textpassage. Die Zellen zeigen an, wie oft das Wort in den Textpassagen vorkommt. Die Zelleneinträge werden mit einer Funktion gewichtet, die angibt, wie wichtig das Wort in der jeweiligen Passage ist und welchen Grad an Informationsgehalt dieses Wort im Allgemeinen hat. Danach wird mithilfe der Single value decomposition die Ausgangsmatrix in drei Matrizen zerlegt. Eine Matrix beschreibt die Zeilen, eine die Spalten als Vektoren und die dritte ist eine Diagonalmatrix. Es ist mathematisch bewiesen, dass keine Matrix perfekt zerlegt werden kann und die Häufigkeiten der zerlegten Matrizen nicht mit der Ausgangsmatrix zusammen passen. Es wird auch eine Matrix erzeugt, die die Ausgangsmatrix auf 2 Dimensionen rekonstruiert. Dieser Vorgang bewirkt, dass sich gleiche Beziehungen gegenseitig anpassen. Dadurch wird die Gruppierung der Bereiche eindeutiger. Die Verbesserung zwischen der Zerlegung und der Rekonstruktion wird mit Hilfe von Korrelation zwischen einem Titel und alle anderen gemessen. "
"data7_00_016.txt";"Schnittstelle zwischen Klassen, die das Zugreifen auf eine andere Klasse ermöglicht!"
"data7_00_029.txt";"Basis - für die Anwender"
"data7_00_031.txt";"Wird zwischen der Superklasse und der Subklasse errichtet, ist ein Zwischenplatz, dass von beiden benutzt werden kann"
"data7_00_032.txt";"Ein Interface ist eine vorgefertigte Form von Programmcode; Es dient zur Vereinfachung."
"data7_00_035.txt";"In Interface gibt es eine Variable von Datentypen, mit diesen Datentypen kann man verschiedene Funktionen schreiben."
"data7_00_038.txt";"Schnittstelle"
"data7_00_041.txt";"Vielgestältigkeit. Verscheidene Klassen haben  gleichen Botschaft. Klassen müssen Methode deklarieren. zum Beispiel interface morgen { public void uhrbestimmt(); } class uhr implementiert morgen { public void uhrbestimmt() { system.out.print(""hi""); } Methode, die nichts mectes, definiert werden"
"data7_00_045.txt";"Wir können auch eine Klasse als interface deklarieren."
"data7_00_046.txt";"interface"
"data7_00_076.txt";"Ein Interface wird verwendet um in einem Objekt Schnittstellen zu definieren."
"data7_00_091.txt";"Interface -> Bytecode -> die Plattformunabhängige Programme Signatur  nur in klasse <- private	wir können mit Interface die alle Klasse <- public		Methoden und Variablen in der Klasse die erzeugte <- packages	aufgerufen werden können oder Klasse und <- protected Parameter  die erzeugte Klasse und auch die Subklasse"
"data7_00_094.txt";"Ist eine einheitliche Struktur"
"data7_05_010.txt";"Interface erweitert die Vererbung in Java. (Nur von einer Klasse aber von vielen Interfaces kann vererbt werden)"
"data7_05_014.txt";"Sind Schnittstellen, die definiert werden um Methoden einheitlich zu"
"data7_05_027.txt";"Interface ist eine Schnittstelle zwischen Objekten Über Interfaces können Objekte mittels Nachricht miteinander kommunizieren."
"data7_05_028.txt";"Schnittstelle, definiert Übergabestelle Kommunikation von verschiedenen Einheiten"
"data7_05_036.txt";"Interfaces sind Anschlußstellen und Platzhalter (zum Beispiel: abstrakte Methode einer Superklasse ist Anschlußstelle für ihre Subklassen)"
"data7_05_040.txt";"Interfaces bestehen aus gleichartige Daten Schnittstellen"
"data7_05_044.txt";"Ein Interface ist ein Programmteil der in die Klasse über das Keyword ""implementiert"" in die Klasse eingebunden wird. Ein Interface kann Methoden beinhalten interface = a class Aclass implements a"
"data7_10_006.txt";"Interface = Schnittstelle. Definiert jenen Bereich wo Methoden und Variablen für andere Klassen zugänglich sind."
"data7_10_008.txt";"Programmteil, um externe Daten öffnen und darauf schreiben zu können. Dadurch verteilte Programmierung möglich => jeder schreibt Package-Teil, der dann über Interfaces abgerufen wird"
"data7_10_012.txt";"Allgemeinen zugänglichen Methoden."
"data7_10_019.txt";"Ein Interface ist für die einheitliche Nützung von Variablen und Methoden gedacht. Zum Beispiel Ein Interface ist dann nötig wenn verschiedene Klassen (zum Beispiel Buch, Fußballfeld) eine gemeinsame abstrakte Methode haben und diese auch nützen wollen, was dann im Interface definiert ist."
"data7_10_030.txt";"Interface ist eine Schnittstelle Zur Kommunikation zwischen Dateien und Programmen außerhalb des ""eigenen Programms"" (zum Beispiel Datenimport, Ausgabe am Bildschirm, Drucker)"
"data7_10_033.txt";"-> ist so eine Art Schnittstelle zwischen Klassen einheitliche Schnittstelle nach außen hin"
"data7_10_037.txt";"Ein Interface ist eine Schnittstelle. Ein Interface wird auch benötigt um ""messages"" verschicken zu können. In einem Interface sind die einzelnen Schnittstellen auch zu anderen Programmen definiert."
"data7_10_048.txt";"Interfaces werden wie Klassen definiert: Interface name { Interfaces bieten Schnittstellen an."
"data7_10_049.txt";"Ein Interface ist eine Schnittstelle die der Kommunikation nach außen dient. Mit Hilfe eines Interfaces kann definiert werden worauf zugegriffen werden soll."
"data7_10_050.txt";"Ein Interface ist die Schnittstelle vom Programm / Komponente mit der Umgebung."
"data7_10_055.txt";"Ein Interface ist eine Schnittstelle zu verschiedenen Klassen, welche miteinander kommunizieren sollen. Es erleichtert den Programmieraufwand und Klassen können Klassen aufeinander zugreifen. In eine Interface wird die Schnittstelle der Klasse definiert."
"data7_10_058.txt";"Interface ist ein Paket aus Methoden und Variablen die in jeder Klasse implementiert werden können. class ... implements Interface 1 (... es müssen allerdings die Variablen einzeln übernommen werden."
"data7_10_065.txt";"-> einheitliche Schnittstelle von verschiedene Klassen."
"data7_10_068.txt";"Interface ist vergleichbar mit abstrakten Klassen. Beinhaltet (static und abstrakte) Methoden. Zur Code Vereinfachung"
"data7_10_070.txt";"Interface = Schnittstelle Interfaces kann man von außen in Klassen implementieren"
"data7_10_072.txt";"Interface = Schnittstellen zwischen verschiedenen Teilbereichen; Erst mit Hilfe von Interfaces wird eine Kommunikation zwischen den Bereichen möglich"
"data7_10_075.txt";"Ein Interface bildet eine Schnittstelle zum Beispiel: Ein Ausgabe -> Ausgabe von Zeichen auf dem Bildschirm"
"data7_10_077.txt";"Interface = Schnittstelle Deklaration = Interface name der Klasse Zugriff = implements Klassenname (Super) Über eine Schnittstelle kann definiert werden, was ein Objekt machen darf oder nicht."
"data7_10_081.txt";"Interface ist die Möglichkeit, eine oder mehrere Klassen eine Schnittstelle zu definieren und anzuwenden. interfaces implement"
"data7_10_090.txt";"In einem Interface wird eine Schnittstelle definiert über die eine Klasse angesprochen werden kann."
"data7_10_093.txt";"Eine Schnittstelle der Klassen."
"data7_10_095.txt";"Mit Hilfe von Schnittstellen / Interfaces können Methoden verschiedener Klassen definiert werden. Die Methoden der Superklassen werden von den Methoden der Subklassen überschrieben."
"data7_15_005.txt";"Ein Interface ist eine einheitliche Schnittstelle in Java. Interfaces treten in Zusammenhang von Vererbung und Abstraktion auf. Subklassen können beliebig viele Interfaces beinhalten."
"data7_15_018.txt";"Ist so etwas wie eine Schablone. Abstrakte Methoden (mehrere) können zusammengefaßt in einem Interface werden um sie später in einem zu implementieren"
"data7_15_071.txt";"in einem interface können Schnittstellen definiert werden; Interfaces benötigt man für eine Mehrfachvererbung in Java -> (sonst nur ""Einfachvererbung"")"
"data7_15_084.txt";"Ein Interface ist eine Schnittstelle, die verschiedene Programm(teile) verbindet und gegenseitig mit informationen (Daten) versorgt. Es wird benögit, damit die Programme miteinander kommunizieren können."
"data7_20_009.txt";"Interfaces dienen auch der Wiederverwendbarkeit von Code. In Interfaces können Schnittstellen zu anderen Programmteilen definiert werden."
"data7_20_011.txt";"Ein Java-Programm kann von mehreren Interfaces erben. In den Interfaces kann nun verschiedene Variablen und Methoden definiert die später weiterverwendet werden  können."
"data7_20_013.txt";"Bedeutet: Schnittstelle.  Man benötigt Interfaces, um einheitliche Schnittstellen herzustellen. Interfaces müssen anders als abstrakte Klassen nicht implementiert werden. Vorteil: Eine Klasse kan von mehreren Interfaces erben."
"data7_20_017.txt";"Ein Interface definiert eine Schnittstelle zu einer Klasse. Ein Klasse kann nur von einer Klasse erben, aber von beliebig vielen Interfaces ""erben"" In Interfaces werden keine Algorithmen implementiert sondern nur die Schnittstellen festgelegt."
"data7_20_020.txt";"Wird benötigt, um zu einer oder mehreren Klassen eine Schnittstelle herzustellen. Durch Interfaces kann gleichzeitig von mehreren Klassen geerbt werden."
"data7_20_021.txt";"Ein Interface wird benutzt zur Definition von Schnittstellen. Interfaces werden durch das Schlüsselwort ""interface"" indiziert und können Basismethoden enthalten. Interfaces müssen durch Verwendung von ""implement"" eingebunden werden."
"data7_20_022.txt";"Interfaces kann man verwenden, ähnlich wie abstrakte Classes, um Strukturen von Objekttypen vorzugeben (zum Beispiel Collection) alle classes, die ein Interface ""implementieren"" müssen auch all seine Methoden implementieren interface foo {} class bar implements foo, bar2 {} Vorteil gegenüber abstract classes:  unbeschränkt viel implements  möglich."
"data7_20_026.txt";"Es ermöglicht Schnittstelle zu einer oder mehreren Klassen ohne Implementierung. Diese Schnittstelle wird vom Compiler sichergestellt. Es wird mit dem Schlüsselwort implements deklariert. Mit Interfaces ist eine ""Art"" Mehrfachvererbung möglich."
"data7_20_039.txt";"Interface ist die Schnittstelle. Über die Schnittstelle werden die Objekte der Klasse(n) miteinander kommunizieren. Es ermöglicht das Verstecken von anderen Teilen des Programmes hinter dieses Interface."
"data7_20_047.txt";"API = Application Programming Interface -> genaue Beschreibung der Inhalte und Funktionen der Packages Dient zur Schnittstellendefinition zwischen verschiedenen Programmteilen und Packages"
"data7_20_054.txt";"In einem Interface werden definiert wie verschiedene Bestandteile kommunizieren können. In Superklassen wird eine Methode abstract definiert sie muß in Subklassen implementiert werden"
"data7_20_059.txt";"Interface ist einheitliche Methodenbezeichnung (Methodennamen und Methodenparameter) sind Schnittstellen, benötigt um die Interaktionen zwischen Klassen (Systemkomponenten) durchzuführen. Man weiss dann, welche Funktion benötigt von anderen und welche zur Verfügung gestellt. Definition: interface interface-Name, Methoden"
"data7_20_060.txt";"Interface in Java ist die Möglichkeit zu einer oder mehreren Klassen eine  Schnittstelle zu definieren und anwenden. Es ist ähnlich wie eine abstrakte Klasse. Interface definiert namen der Methode und name der Variable."
"data7_20_062.txt";"Ein Interface definiert Schnittstellen zwischen Objekten. Ein Interface wird wie eine Klasse deklariert und beinhaltet die Methoden für den Nachrichtenaustausch. Anstatt der Deklaration der einzelnen Methoden mit ""abstract"" (abstract bedeutet, dass in jeder abgeleiteten Klasse diese Methode stehen muss.) werden diese Methoden in einem Interface zusammengefaßt."
"data7_20_067.txt";"In einem Interface können Variablen und Methoden vereinheitlicht werden, um eine geeignete Schnittstelle zu anderen Objekten herzustellen."
"data7_20_069.txt";"Ein Interface ist eine Schnittstelle; Mit einem Interface kann definiert werden welche Klasse welche Schnittstellen erhält. Eine Klasse kann nur mit einer weiteren Klasse aber mit mehreren Interfaces verknüpft sein."
"data7_20_073.txt";"Ein Interface erlaubt sozusagen ""Mehrfachvererbung"" eine Klasse kann mehrere Interfaces implementieren und somit die Methoden anderer Klassen aufrufen."
"data7_20_082.txt";"Interface ist eine Zusammenfassung von Variablendeklarationen und Methodendeklarationen, die jede Klasse übernehmen kann. Vorteil auch, dass Klassen mehrere Interfaces verwenden können."
"data7_20_083.txt";"Schnittstelle es können die Namen der Variablen und die Namen der Methoden (-> parameter und Rückgabewerte) definiert werden."
"data7_20_085.txt";"Ein Interface ist ähnlich einer Klasse zu implementieren, kann jedoch nur konstante Variablen haben. Es definiert eine Schnittstelle zwischen verschiedenen Klassen und Objekten. Es legt die Verhaltensweise der Objekte miteinander fest."
"data7_20_088.txt";"Interface ist eine gemeinsame Schnittstelle der Klassen. Wenn Interfaces deklariert werden bedeutet es, dass diese als Interface deklarierte Klassen eine gemeinsame Schnittstelle haben, so können die Methode und Variablen untereinander ausgetauscht werden. Interface dienen zur leichteren Austausch der Programmteile, und eine bessere Übersichtlichkeit."
"data7_20_092.txt";"Ein Interface ist einer abstrakten Klasse ähnlich, jedoch ohne Implementierung. Die Deklaration erfolgt durch das Keyword Interface, aufgerufen werden sie mit Implements Durch Interfaces ist in Java eine Art Mehrfachvererbung möglich."
"data7_20_096.txt";"Ein Interface ist eine Schnittstelle die Objekten erlaubt bestimmte Merkmale weiterzugeben. So kann eine Subjklasse nur von einer Superklasse erben, jedoch von mehreren Interfaces."
"data7_25_001.txt";"Interface wird benötigt um ""Mehrfachvererbung"" zu ermöglichen. Im Interface werden Methoden definiert die in Klassen implementiert werden können."
"data7_25_015.txt";"Interface ist eine Schnittstelle  (eine Art von Mehrfachvererbung) In einem Interface können Variablen und Methoden definiert werden."
"data7_25_023.txt";"Ein Interface ist eine Schnittstelle für ein Programm beziehungsweise mehrere Klassen. code: interface anInterface; Durch das importieren mehrerer Interfaces ist eine Art Mehrfachvererbung möglich code class AClass implements anInterface1 anInterface2;"
"data7_25_061.txt";"Ein Interface ist eine Schnittstelle zwischen (Sub) Klassen in welchen Variablen und Methoden definiert werden können, die andere Klassen benutzen."
"data7_25_079.txt";"Ein Interface ist predefinition. Da kann man Variablen definieren und die Funktionen, aber nicht implementieren. Um ein Interface zu implementieren muss man eine Klasse definieren mit ""implements Interface"". zum Beispiel interface student {int mn; int jahre; } class student_work implements student {..."
"data7_30_007.txt";"Interface ist eine ""Vorlage"" die es ermöglicht die in Java mögliche Einfachvererbung zu umgehen und daraus ""Mehrfachvererbung"" zu erlangen. Interfaces offerieren Funktionen und Variablen Variablen müssen Konstante sein; Methoden müssen bei der Verwendung ""public"" deklariert werden. Zum Beispiel interface Uni {...} public class Pruefung implements Uni {...} Methoden werden bei Ihrer Verwendung konkretisiert"
"data7_30_034.txt";"In Java gibt es nur einfache Vererbung, keine mehrfach Vererbung. Das bedeutet, daß jede Klasse nur von einer Superklasse erben kann. Durch interfaces wird dies möglich (mit implements). Man kann Variablen und Methoden definieren. Eine Klasse kann beliebig viele Interfaces implementieren."
"data7_30_051.txt";"Möglichkeit, zu verschiedenen Klassen eine Schnittstelle zu definieren und anzuwenden. wie abstrakte Klasse, aber keine Implementierung! definiert Name der Methode Parameterliste Rückgabewerttype Name der Variable (als static und final deklariert)"
"data7_30_052.txt";"Ein Interface erlaubt es eine einheitliche Struktur zu schaffen. Alle in eine Interface geschriebene Methode müssen in der Klasse, in die das Interface importiert wird näher beschrieben werden, das heißt im Interface werden die Methoden noch nicht fertig implementiert."
"data7_30_056.txt";"Interface ist Schnittstelle der Komponenten nach außen. Im Interface werden die eigenschaften und verhalten der Klasse definiert."
"data7_30_064.txt";"lässt Art von ""Mehrfachvererbung"" zu In Interface können Methoden definiert werden eine Art von Schnittstelle"
"data7_30_097.txt";"Interface = Schnittstelle nach außen. Ein Interface ist wie eine abstrakte Klasse. Wenn eine Klasse ein Interface implementiert muss es seine Methoden implementieren oder die Klassenmethoden als abstrakt deklarieren. Eine Klasse kann von mehreren Interfaces erben. Zum Beispiel: Klassenname implements Interfacename Interfaces werden mit Interface deklariert: zum Beispiel Interface Writer"
"data7_35_043.txt";"In Java ist die Möglichkeit zu einer oder mehreren Klassen eine Schnittstelle zu definieren und anzuwenden. Ein Interface ist ähnlich wie eine abstrakte Klasse, enthält jedoch keine Implementierung. es definiert Namen und Methoden, deren Parameterlisten (Paramtertype und namen) deren Rückgabewerttypen Namen und Variable"
"data7_35_063.txt";"= Schnittstelle. In einem Interface definiert man Methoden, die in späteren Klassen implementiert sein sollten. In Java kann durch Interface das Konzept einer ""Mehrfach Vererbung"" realisiert werden und einheitliche Implementierung der Klassen gewährleisten."
"data7_35_074.txt";"Interface (Schnittstelle) definiert die Menge der Methoden die von den Subklassen geerbt und implementiert werden können. Interfaces werden zur Mehrfacherbung benötigt, da eine Subklasse von nur einer  Superklasse, oder mehrere Interfaces erben kann."
"data7_35_080.txt";"Ein Interface wird über den Klassennamen als solches definiert. interface anInterface Es beinhaltet Klassen und Methoden. Der Zweck eines Interfaces besteht darin, Schnittstellen zu definieren. Im Interface wird nur die Signatur einer Methode implementiert. Der Rumpf wird erst in den untenstehenden Klassen implementiert. In Java gibt es keine Mehrfach-Vererbung. Eine Subjklasse kann aber quasi von mehreren interfaces ""erben"". Mit Interfaces kann daher auch in Java eine Art von Mehrfachvererbung erreicht werden."
"data7_35_087.txt";"Ein Interface ist eine Vorlage die einer Klasse Schnittstellen  vorschreibt das hießt es werden sowohl Klasse, Methoden und Variablen als abstract gesetzt und müssen dann in der Klasse implementiert werden. Anwendung: zum Beispiel: class Auto implements Fahrzeug (Interfacename) { }"
"data7_35_089.txt";"Interface bieten zusätzliche Funktionen auf die zugegriffen werden kann; Schnittstelle zu anderen Komponenten Da in Java nur von einer Klasse geerbt werden kann, kann man Interfaces (durch implements name in der Signatur) ein oder mehrere Interfaces implementiert werden Definiert werden können Methoden."
"data7_40_002.txt";"Interface in Java macht es möglich für eine oder mehrere Klassen Schnittstellen zu definieren und anzuwenden. Definiert sind: Namen der Methode parameter (Typ und Bezeichner) Rückgabewerttyp Namen der Variable Eine Klasse kann nur von einer Klasse erben. Interfaces ermöglichen die Mehrfachvererbung."
"data7_40_003.txt";"Möglichkeit zu einer oder mehreren Klassen eine Schnittstelle zu definieren und anzuwenden. Ähnlich abstrakten Klassen jedoch beinhalten sie keine Implementierung. Sie definieren Signaturen von Methoden: Namen von Methoden (deren Parameterliste und Rückgabewerttyp) Name von Variablen (implizit static und final) Interface besteht ausschließlich aus Konstanten und abstrakten Methoden."
"data7_40_004.txt";"Interfaces dienen dazu eine einheitliche Schnittstelle zu erzeugen. In einem Interface kann man Variablen und Methoden definieren. Mit Interfaces ist eine Art Mehrfachvererbung möglich."
"data7_40_025.txt";"Durch Interfaces können Klassen eine einheitliche Struktur haben. Dadurch werden die Klassen (und der Code) übersichtlicher, man kann Fehler leichter vermeiden bzw. finden."
"data7_40_057.txt";"Interface ist wie eine abstrakte Klasse, aber ohne Methoden, die nicht abstract sind. Es ist eine Schnittstelle, die man verwenden kann, so dass alle Klassen, die eine (oder mehrere) Interface implementieren, gleiche Funktion haben. Alle Methoden und Variablen des Interfaces sind public und static."
"data7_40_066.txt";"Interfaces sind Namens / Schnittstellendefinitionen Methoden und Interface sind abstract (=> können also nicht instantiiert werden. Lösen somit das Proglem der nicht vorhandenen Mehrfachvererbung in Java. Eine ""Subklasse"" kann zwar nur von 1 Superklasse erben, aber mehrere Interfaces implementieren."
"data7_40_078.txt";"In Java gibt es die Möglichkeit zu einer odermehreren Klassen eine Schnittstelle nach außen zu definieren und anzuwenden. Ein Interface ist ähnlich wie eine abstrakte Klasse enthält aber keine Implementierung. Interface definiert Namen und Methoden. Eine Subjklasse kann von beliebig vielen Interfaces und maximal einer abstrakten Klasse erben."
"data7_40_086.txt";"Eine Subklasse kann von beliebig vielen Interfaces und einer Klasse erben (= Interface Implementierung) Möglichkeit eine Schnittstelle zu definieren und anzuwenden, ähnlich wie abstrakte Klassen. Jedoch keine Implementierung. Ein Interface definiert Namen von Methoden, deren Parameterliste, deren Rückgabewerttypen und Namen der Variablen (static, final)"
"data8_0_06.txt";"Reverse Engineering, Redefinition oder Programmüberarbeitung Hohe Flexibilität geringere Wartung Schnellreaktionen zu neuen Entwicklungen"
"data8_1_01.txt";"Bei Reengineering liegt der Nutzen bei Kostensekung bei Wartungsaufgaben Qualitätsverbesserungen, Motivation und Flexibilitätssteigerung. Weiters kann man sich durchaus einen Wettbewerbsvorteil durch Effizienzsteigerung herausholen. Vorteile hier wären Produktivitätssteigerung, Lebenszyklusverlängerung, Migration auf neue Plattformen."
"data8_3_02.txt";"Reeningeering: Nutzungsdauer verlängern Wartbarkeit des Systems erhöhen Design- oder Komplexitätsprobleme beseitigen um Systemerweiterung oder -integration zu ermöglichen Wartungsproduktivität erhöhen um zukünftige Änderungen schneller durchführen zu können Neuentwicklung wäre teuer Altsystem nicht ausreichend dokumentiert und Schnittstellen für die Anbindung neuer Komponenten fehlen"
"data8_3_11.txt";"Reengineering: Vorteile: Nutzungsdauer eines Systems verlängern, die Wertbarkeit erhöhen, Neuentwicklung meist teurer, Komplexitätsprobleme Standardprodukt: meist Komplettlösung mit Installation und Wartung. Problematisch könnte die Einbindung von Altsystemen sein."
"data8_3_12.txt";"Reengineering falls man den Produktlebenszyklus des bestehenden Systems verlängern will. Weiters sollte die Funktionalität (und technische Qualität) und die Anwenderzufriedenheit (unter betriebswirtschaftlichen Aspekten) ein Mindestmaß nicht unterschreiten. Sollte dieses Mindestmaß unterschritten sein, beziehungsweise sollten die betrieblichen Prozesse nicht durchgängig abgebildet (integriert) sein, empfiehlt sich eine neue Standardlösung."
"data8_3_13.txt";"Reengineering (Integrierung des Altsystems): Nutzungsdauer des Systems zu verlängern; Wartbarkeit zu verbessern; kostengünstigeres Konfigurieren.  Standardprodukt: allgegenwärtig am Markt; Suchen des am besten geeigneten Herstellers; immer am letzten Stand der Technik, durch Online-Aktualisierungen."
"data8_3_28.txt";"Reengineering günstiger als Neuentwicklung / Kauf Nutzungsdauer wird erhöht, bessere Warbarkeit, Beseitigung von Komplexitätsproblemen -> Integration von neuen Systemen möglich, Steigerung der Wartungsproduktivität -> Änderungen leichter durchführbar. Individuallösung besser abgestimmt auf das Unternehmen."
"data8_3_34.txt";"Solange das Individualsystem, das in der Regel genau auf das Unternehmen und die Geschäftsprozesse abgestimmt ist, von den Anwendungen und der Benutzerfreundlichkeit, den Anforderungen des Unternehmens enspricht, sollte es beibehalten werden. Nur bei Mängeln oder nichtausreichender Funktionalität sollte auf ein Standardsystem, das in der Regel eher allgemeine Funktionen hat zurückgegriffen werden."
"data8_3_35.txt";"Die Gründe für ein Reengineering liegen in der verlängerten Nutzungsdauer des Systems, der Senkung der Wartungskosten und gleichzeitiger Steigerung der Wartungsproduktivität sowie der Motivationserhöhung in der IS-Abteilung. Zudem ist ein Reengineering in den meisten Fällen günstiger als eine Neuentwicklung. Für die Neuentwicklung spricht besonders der Tatbestand, daß bei Altsystemen oft der Einsatz von neuen Technologien, zum Beispiel Protokollen nicht möglich ist oder bestimmte Schnittstellen nicht existieren. Man nennt diese Problematik die sogenannte Erblast von Altsystemen."
"data8_3_37.txt";"Nutzungsdauer verlängern, Wartbarkeit des Systems erhöhen, Neuentwicklung oft teurer; Altsysteme oft nicht ausreichend dokumentiert oder Schnittstellen fehlen; Vorteil des Reengineering auf jeden Fall Lebenszyklusverlängerung, Qualitätsverbesserung, Migration auf neue Plattformen"
"data8_4_03.txt";"Beibehaltung des Individualprodukts: - Kostenfaktor - Altsystem besser bekannt, auch Mitarbeitern - Durch Reengineering kann Altsystem verbessert werden - spätere Änderungen wieder nur mit hohem Aufwand verbunden  Standardprodukt: - bessere Integration - Altsystem zu alt, oder komplex um ein Reeingeneering durchzuführen - Standardprodukt einheitliche Struktur, eventuell auch länderübergreifend - bessere Effizienz in IS-Bereich -> Wettbewerbsvorteil"
"data8_4_04.txt";"Reengineering: Lebenszyklus verlängern, kurzfristig sicher kostengünstiger, keine Schwierigkeiten beim Übetragen der Daten! Standardprodukt: unter Umständen lange Implementierungszeit (+ für Reengineering) Erweiterung zu handel und Zulieferer eventuell möglich! langfristig wahrscheinlich bessere Entscheidung"
"data8_4_05.txt";"Reengineering => ween Altsystem integriert werden kann. Durch Reengineering kann man migrieren auf neue Plattform ohne gesamtes System auszuwechseln. man verlängert die Nutzungsdauer des Systems. man erhöht die Wartbarkeit und Wartungsproduktivität des Systems. Standardprodukt: ganzes neu System. Es können auch ausgewählt werden. Weil du kannst die Standardprodukte gleichzeitig benutzen (verkäufer und dam Benutzer) Lieferanten ist verantwortlich für Wartung und Pflege Diese Produkte sind schon ausprobiert worden (Es gibt Erfahrung)."
"data8_4_08.txt";"Reengineering: Verlängerung der Nutzungsdauer Benutzer sind mit System vertraut Verringerung der Wartungstätigkeiten Verringerung der Komplexität des Altsystems Erhöhung der Produktivität Erzielung von Wettbewerbsvorteilen Erhöhung der Benutzer-Zufriedenheit Standardprodukt: Altsystem stellt eine Altlast dar Altsystem zu wenig flexibel Reengineering des Altsystems könnte sehr kosten- und zeitintensiv sein und könnte zu größeren Produktivitätsverlusten führen Standardprodukt ist eine bewährte Lösung Kosteneinsparung: Support und Wartung eventuell billiger als bei Altsystem"
"data8_4_20.txt";"Warum Reengineering? Verlängerung der Nutzungsdauer Erhöhung der Wartbarkeit Erhöhung der Wartungsproduktivität Design- und Komplexitätsprobleme beseitigen Neuentwicklung zu teuer Altsystem: nicht ausreichend dokumentiert fehlen von Schnittstellen zur Anbindung neuer Komponenten Probleme bei Individualprodukt: keine Software-Komponenten am Markt Problem des Wartens und des Services."
"data8_4_21.txt";"Grundsätzlich ist das Reengineering kostengünstiger und oft auch einfacher in der Handhabung (eventuell keine neuen Einschulungen, etc.). Außerdem ist das Anschaffen neuer Hardware unter Umständen nicht notwendig. Die Frage ist, wie das Altsystem aufgebaut ist. Der Aufwand ist abzuschätzen und auf Grund dessen eine Entscheidung zu treffen. Standardsoftware hat den Vorteil der eventuellen Überlegenheit in funktionsumfang, Benutzerfreundlichkeit, Wartbarkeit, etc. Außerdem ist es unter Umständen möglich, das neue System schneller zu integrieren, versus ein Reengineering => (Zeitaufwand)."
"data8_4_27.txt";"Reengineering: bestehende Prozess könnte um Funktion erweitert werden neue Produkt ist zu teuer Verbesserung mittels Reengineering vervollsätndigen der Dokumentation um bessere Wartung zu ermöglichen Restrukturierung des Codes Standardprodukte: man weiß worauf man sich einläßt oft teure Wartung (bei SAP 50 % Wartungskosten)"
"data8_4_38.txt";"für die beibehaltung spricht, dass ein individualprodukt bestmöglich an schon bestehende geschäftsprozesse angepasst werden kann. sollte es jedoch nicht mehr den aktuellen anforderungen entsprechen, könnte ein teures Reengineering notwendig werden, insbesondere bei zu komplexen oder schlecht dokumentierten individualentwicklungen. ein standardsprodukt liesse sich dann vielleicht billiger installieren, allerdings könnte es nötig sein, die eigenen geschäftsprozesse daran anzupassen."
"data8_4_41.txt";"Beibehaltung: individuelles produkt kostet mehr als standard produkt. standardprodukt kann nicht alle probleme des betriebes lösen um zu Reengineering des individualprodukts brauchen wir IT Kräfte deshalb personalkosten höher werden. und also eine neue programerstellung kostet auch zu viel (zum Beispiel SAP)"
"data8_4_46.txt";"standardprodukt leichter zu bedienen beziehungsweise zu erlernen; keine besonderen kenntnisse erforderlich; mitarbeiter können schnell produktiv werden; nachteil: mögliche sicherheitslücken. reengineering: bessere wartbarkeit, längere lebensdauer; Funktionsausbau, keine teure neuinvestiton für neues produkt; effizienzsteigerung bei diversen prozessen nachteil: wenn produkt sehr schelcht aufgebaut -> mit Reengineering kommt es einer neuentwicklung gleich"
"data8_5_18.txt";"Nachdem das Unternehmen sein Produktprogramm erweitern und expandieren will, stellt sich die Frage, ob das derzeitige System diese Umstellung mitmachen kann (und wenn ja, zu welchem Preis). Die Beibehaltung ist zu empfehlen, wenn der technische Stand noch und eine gute Dokumentation gegeben ist. In diesem Fall wäre eine ERweiterung wohl die kostengünstigere Lösung (und ist auch mit geringerem zeitlichen und organisatorischen Aufwand umsetzbar). Für ein neues Standardprodukt würden eine schlechter technischer Stand des Systems, schlechte Wartbarkeit, eine ungenügende Dokumentation sowie das Fehlen von Schnittstellen für  die neuen Anforderungen sprechen."
"data8_5_22.txt";"Reengineering: unterscheidet man zwischen Revers und  Fordward Reengineering: Forward: höherer auf eine niedrigere Abstraktionseben: Reverse: Extraktion von Information Warum Reengineering: Altsystem integrieren kann niedrigere Kosten Nutzungsdauer verlängern Wartbarkeit wieder vorhanden, nicht so kompliziert; Vereinfachung. Wiederverwendbarkeit; Spezifikation; Standardprodukt: keine neue Entwicklung -> somit keine Fehlerquellen (Daten, Softwareschutz); leicht erlernbar für den Mitarbeiter; individuell gestalten, keine besonderen Fachkenntnisse; keine IT Fachkräfte notwendig; Wartung eventuell kostengünstiger."
"data8_5_43.txt";"Individualentwicklung ist im vergleich zu fremderstellung billiger das system kann durch das Reengineering ergänzt, saniert werden. Möglichkeiten sind reverse engineering: rückentwicklung um auf die anfangsdaten zu kommen sanierung: es werden einzelne aktivitäten ausgesucht die nicht richtig funktionieren, werden überarbeitet und ersetzt ergänzung: fehlende daten werden hinzugefügt miteinbeziehung der mitarbeiter bei der entwicklung, wodurch die motivation steigt keine bindung an einen anbieter standardprodukt: is in der regel für klein- und mittelbetriebe zu teuer, es entstehen kosten bei der anpassung, vielleicht auch einschulung der mitarbeiter. das unternehmen green bull würde sich an den anbieter binden, der vorteil wäre die wartung und pflege des systems durch den anbieter (keine likale installation und wartung) kosten: pauschalgebühr oder auf nutzungsbasis"
"data8_5_45.txt";"für das Reengineering sprechen qualitätsverbesserung, leistungsverbesserung flexibleres produkt. für die beibehaltung des individualprodukts sprechen vor allem die kostengründe und dass die mitarbeiter schon voll auf das system eingelernt sind. das heißt es sind wahrscheinlich umschulungen nötig. für das standardprodukt spricht, dass es höchst wahrscheinlich in einer sprache formuliert ist, die dann sehr gut mit anderen erp-systemen zusammenarbeiten kann. das bedeutet, dass eine erleichterte interaktion zwischen verschiedenen unternehmen möglich ist. Im falle von green bull vor allem die zu beliefernden geschäfte."
"data8_5_47.txt";"beibehaltung - günstiger, durch Reengineering könnte vorhandenes System verbessert werden. standardprodukt oft  sehr teuer und benötigen eventuell zusätzliches personal zur wartung. standardprodukt: system übernimmt kernprozesse des unternehmens. neue bereiche können übergreifend hinzugefügt werden. zeitnahe datenbank, dadurch verhinderung von redundanzen lebensdauer länger"
"data8_5_48.txt";"Vorteile Reengineering geringere kosten, da produkt bereits vorhanden -> nur verbesserungen notwendig keine übertragung der vorhandenen daten in das neue produkt erforderlich. firma bereits mit älteren produkt vertraut bessere individualanpassung an das unternehmen nur die komponenten die auch tatsächlich benötigt werden -> bei standardprodukten -> viele funktionen -> unüberschaubar möglichkeit zur ausführlichen dokumentation vorteile standardprodukt: geringerer zeitaufwand asp outsourcing"
"data8_6_07.txt";"Bei der Beibehaltung / Weiterentwicklung können die Datenbestände so bleiben wie sie vorliegen und müssen nicht umgestellt werden. Außerdem ist die Eigenentwicklung an die Anforderung des Unternehmens angepaßt. Bei einem Standardproduktmuss der Datenbestand konvertiert werden. Zumeist sind aufwendige Customizing-Schritte notwendig. Auf lange Sicht ist ein Standardprodukt billiger und bei Fehlern kann man  sich beim hersteller regressieren (wenn Schaden vorliegt)."
"data8_6_09.txt";"Für die Beibehaltung sprechen unter anderem die geringeren Kosten. Reengineering kann ebenso die Produktivität steigern, den Lebenszyklus verlängern, die Wartungskosten senken. Außerdem führt Reengineering durch die Effizienzsteigerung auch zu einem Erfolg am Markt. Ein Standardprodukt wie SAP wäre dagegen sinnvoll, da die Firma ja expandiert und somit auch um einiges Gräßer wird. Dieses Programm wäre dann von Grund auf darauf angelegt und etwaige Altlasten aus dem Altsystem (die bei einer Vergrößerung des Unternehmens hinderlich sein könnten) würden wegfallen. Standardprogramme werden ja dann ohnehin an manche individuellen Bedürfnisse angepasst nur hat es von haus aus schon die Komponenten beziehungsweise Programmierung, die für ein größeres Unternehmen geeignet sind."
"data8_6_10.txt";"Standardprodukt ist möglicherweise für die internationale Erweiterung besser gerüstet durch lokalisierungsoptionen. Reengineering ist nur ratsam, wenn das Legacy Stem gut dokumentiert ist und der Code leicht verständlich und gut strukturiert. Es gäbe die Möglichkeit des Reverse- & Forward Engineering. Standardprodukt würde bei einer Big Bang Einführung möglicherweise große Umstellungsaufwände / Schulungsaufwände bedeuten."
"data8_6_14.txt";"Beibehaltung: Reengineering billiger Mitarbeiter kennen System Motivation steigt Altsystem kann Weiterverwendet werden Bessere Anpassung an Unternehmen.  Standard: Wartung durch externen Anbieter Externe (bessere) Programmierer Wartung teuer % % von Lizenzumsatz) Keine Eigenen Programmierer notwendig."
"data8_6_16.txt";"Beibehaltung / Reengineering: speziell auf Betrieb angepasst bestehende Daten können weiterverwendet werden weniger Umstellungsprobleme Hardware kann eventuell beibehalten werden Wartungsaufwand wird verringert.  Standardsoftware: bessere Kompatibilität zu Firmenexternen besserer Support billiger aussgereiftere Produkte Wachsen leicht möglich."
"data8_6_17.txt";"Für Beibehaltung: individuell an jeweilige Geschäftsprozesse angepasst Mitarbeiter sind System gewohnt (Umschulung wäre notwendig) Umstieg auch teurer, aufgrund Lizenzgebühren Total Cost of Ownership beachten (Anschaffung, Wartung) Service, Update) technische Qualität Erweiterung Beibehaltung (eventuell kleine Anpassungen) Neuentwicklung beziehungsweise Umstieg, Sanierung, Benutzerzufriedenheit, Reengineering Für Standardsoftware spricht vermutlich fehlerfreier -> gut ausgetestet Anbieter für Funktion verantwortlich"
"data8_6_19.txt";"Eine Individualentwicklung ist den Bedürfnissen des Unternehmens angepasst. Bei einem Standardprodukt ist dies nicht der Fall, hier muss sich die Firma oft der Software anpassen. Vorteile von Standardsfotware sind, dass diese im Vergleich günstiger sind, sie für verschiedene Sprachen erhältich sind (neue Mitarbeiter in Osteuropa). Das Standardprodukt hat schon definierte Schnittstellen, bei der Selbstentwicklung muss dies nicht immer der Fall sein. Ein Reengineering könnte kompliziert werden, wenn nicht gut und auführlich dokumentiert wurde. Sollten nur kleine Anpassungen notwendig sein ist ein Reengineering sicher vorteilhaft."
"data8_6_23.txt";"Invidividualprodukt: Produkt ist den Mitarbeitern bekannt hat sich bewährt erweiterbar kostengünstiger als Neuentwicklung Verlängerung des Lebenszyklus einfachere Wartung international nicht umsetzbar entspricht nicht den neuen Anforderungen sprachliche Barrieren  Standardprodukt: hoher Standardisierungsgrad Einschulung und Wartung des Produktes durch SAP hohe Lizenzgebühren - teuer Einschulung der Mitarbeiter jetziges Programm wertlos"
"data8_6_25.txt";"Gründe Beibehaltung: Da individuell: auf die Anforderungen des Unternehmens abgestimmt. Frage? Ist das System einer Osterweiterung gewachsen => welche Kosten verursacht diese Erweiterung wenn das System angepasst werden muß, ist es überhaupt möglich? wenn das OK -> Beibehaltung => sonst Analyse Qualität Benutzerfreundlichkeit, Anpassung, Behaltung, Neu, Reengineering 0> Wenn eine Anpassung bzw. Reengineering teurer ist als ein Neusystem (inklusive Datentransfer!) dann Neusystem -> sonst Altsystem und Schulung, Software, Hardware, Total costs of Ownership berücksichtigen auch hier (Schulung und Wartung)"
"data8_6_26.txt";"Die Individualentwicklung ist maßgeschneidert und hat schon viel Geld gekostet, weitere Investitionen sind als geringer einzuschätzne als die Neuinvestition in ein Standardsystem. Auf lange Sicht gesehen, schätze ich aber die Kosten eines Standardsystems als geringer ein, da die Entwicklung zentral und kostengünstiger bei SAP oder Microsoft, etc. gemacht werden kann. Standardsysteme können aber nie genau das Unternehmen und die Geschäftsprozesse abbilden, die Individuallösungen bieten, dafür ist die Dokumentation und die Problemlösung, falls Fehler auftreten besser bei Standardsystemen, ebenso vermutlich die Benutzerfreundlichkeit des Systems, da es oft im Look-and-feel an andere bekannte Softwareprodukte angepasst ist."
"data8_6_29.txt";"Gründe für Beibehaltung: Umstellungskosten -> für Software und Hardware und Umschulung der Mitarbeiter hohe Lizenzkosten von Standard-Software (Beispiel SAP R/3) Reengineering zur Verlängerung der Lebensdauer und Erhöhung der Wartbarkeit des ERP-Systems Gründe für Umstieg auf Standard-Software: Hersteller-Erfahrung Software ist intensiv getestet nahezu fehlerfrei / sehr stabil eventuell Kompatibilitätsüberlegungen."
"data8_6_30.txt";"Reengineering / Beibehaltung bei hohen Kosten für Standardprodukt wenig Komplexität gleichbleibenden Anforderungen (oder geringen Änderungen) Wartungskosten ebenfalls meist hoch bei Standardprodukten Für Standardprodukt spricht eben Standardisierung Erfahrung Anbieterseitig weniger Aufwand, knowhow nicht erforderlich"
"data8_6_31.txt";"Reengineering des Individualproduktes Verlängerung der Lebenszeit des Individualproduktes Bessere Nutzung des Produktes, welcher noch genutzt werden sollte den Bedürfnissen des Unternehmens eher anpassbar als die Anschaffung des (fertigen) Standardproduktes  Standardprodukt Ermittlung des Aufwandes erfolgt aufgrund Marktpreis Standardprodukte haben einheitliche Architektur Standardprodukte beinhalten Serviceleitstungen des Herstellers"
"data8_6_32.txt";"Ein Individualprodukt ist genau auf die Wünsche der Firma zugeschnitten - ein Standardprodukt nicht - beziehungsweise muss durch Spezialisten angepasst werden. Wenn jemand im Unternehmen das Standardprodukt kennt und es dementsprechend programmieren kann, dann ja, ansonst beläuft sich die Wartung auf sehr hohen Kosten. Für ein Reengineering spricht des weiteren die bereits eingesetzten Ressourcen sowie eingeschultes Personal und Anwender. Durch die Neueinführung fallen so zusätzliche Kosten an. Ein gutes Reengineering ist sicher ein großer Vorteil."
"data8_6_33.txt";"Individualprodukt ist sicher genau auf die Prozesse von Green Bull zugeschnitten. Mit einem Reengineering können sie dieses noch Leistungsfähiger, leichter und vor allem billiger zu warten, benutzerfreundlichere, vielleicht  bessere Dokumentieren machen. Nachteil ist, daß sie immer wieder Neu beziehungsweise Dazuentwickeln müssen. Bei Standard ERP ist dagegen schon alles notwendige vorhanden. Man muss es nur zukaufen und gegebenenfalls ein wenig Customizen. Es ist weiters schon öfters erprobt und damit nicht so sehr Fehleranfällig -> Bei Individual können viele Kinderkrankheiten entstehen."
"data8_6_36.txt";"für Reengineering: Dieses System bildet unter Umständen die betrieblichen Prozesse dieses Unternehmens besser ab als eine Standardsoftware. Das Unternehmen benötigt nur bestimmte Funktionen der Standardsoftware und könnte vieles gar nicht verwenden. Durch ein Hinzufügen der benötigten Funktionen könnte die Lebensdauer des Systems verlängert werden. Für Standardsoftware: untersützt die wichtigsten betrieblichen Funktionen, weniger fehleranfällig, durch Hinzukaufen von Komponenten leichter erweiterbar, Wartung und Pflege kann abgegeben werden."
"data8_6_39.txt";"für eine beibehaltungs preochen: das ERP system wurde individuell für das unternehmen erstellt, entwicklungskosten waren sicher teuer, system ist im unternehmen schon etabliert, mitarbeiter schon eingelernt. Reengineering: das system als ganzes kann beibehalten werden, es werden erneuerungen durchgeführt, die eine verbesserung der benutzerfreundlichkeit mit sich bringen können systemfehler können ausgebessert oder minimiert werden, aus alten anforderungen kann gelernt werden standardprodukt: leichte benutzerführung, geringere kosten als individualentwicklung enthält basisfunktionen, die für eine grosse anzahl von kunden gefordert wird."
"data8_6_40.txt";"Individualprodukt mit Portfolioanalyse feststellen, ob Reengineering sinn macht technische qualität, benutzerzufriedenhett und betriebswirtschaftliche möglichkeit, erweitern, ersetzen, eventuell nur noch dokumentieren, Reengineering falls eigenes produkt technisch und funktionell zufriedenstellend und personal mit know how über die eigentwicklung vorhanden, sollte dieses weitergeführt werden. Falls: personal nicht mehr da oder eigenes produkt technisch veraltet oder den gestiegenen anforderungen nicht mehr genügt => Standardprodukt vorteile: große Funktionalität alles integriert moderne architektur kein teures entwicklungspersonal mehr notwendig lizenzpreise wahrscheinlich zu verkraften."
"data8_6_44.txt";"Vorteil standardprodukt unter umständen billiger man benötigt keine eigene it abteilung oder it mitarbeiter leicht erlernbar nachteil sicherheitsmangel verwaltung der dokumente vorteil Reengineering geringe oder wenig Einschulung der mitarbeiter nutzungsdauerverlängerung könnte auch billiger sein never change a running system"
"data9_0_01.txt";"Anforderungsanalyse: Spezifikation der Anforderungen (Lastheft) Verbale Darstellung der Anforderungen Definition: formale Darstellung der Anforderungen (Pflichtenheft) Verhandlung"
"data9_0_02.txt";"Zunächst ist es einmal wichtig festzustellen, für welche einsatzgebiete im speziellen unser system eingesetzt werden soll. dabei sollten die personen befragt werden, die später damit arbeiten sollen. aus den unterschiedlichen ist- und soll-zustand ergeben sich die anforderungen für die beschaffung der neuen hard- und software."
"data9_0_03.txt";"Zu beachten ist welche spezifikationen das system hat. mit verschiedenen methoden kann man die anforderungen an das system messen. zum Beispiel Software-metriken, function points. anhand von verschiedenen kriterien (interne, externe datenbestände, schnittstellen, ...) werden verschiedene punkte vergeben und entsprechend gewichtet, um einen überblick über den umfang des projekts zu bekommen. function points sind unabhängig von codezielen im gegesatz zu loc (lines of code), die den softwareumfang anhand von codezeilen definieren, gewichtet nach der programmiersprache. problem hierbei 10 zeilen rekursion sind aufwändiger als 10 zeilen zuweisungen von variablen."
"data9_0_04.txt";"Analyse ist situation hardware software analyse des marktes ziele für die nächsten 5 - 10 jahre"
"data9_0_05.txt";"man kann vier eigenschaften von anforderungen nennen anforderungstyp -> hat auswirkungen auf die schwierigkeiten die sich durch eine änderung der anforderungen ergeben. anwendungsbereiche der anforderung -> produkt-parameter (bezieht sich auf das zu entwickelnde produkt) projekt-parameter (bezieht sich auf die erstellung des produkts) einhaltung der anforderungen -> grad der notwendigkeit der umsetzung einer anforderung obligatorisch, anleitung, information prioriatäten -> relative wichtigkeit einer anforderung, Kosten, zeitlicher ablauf strategisch wichtige langfristige anforderungen quelle der anforderungen -> management"
"data9_1_06.txt";"Schritte bei der anforderunganalyse anforderungsspezifikation: die anforderungen sollen hier so gut und so exakt wie möglich beschrieben werden. repräsentation: vorstellung der ergebnisse auf verschiedene arten. verwendung unterschiedlicher modelle (verschiedene Sichten) um die anforderungen besser zu veranschaulichen. verhandlung: da unterschiedliche personen unterschiedliches wissen, anforderungen an das system, erwartungen und ansichten haben soll eine lösung gefunden werden, die von allen akzeptiert wird dies geschieht zum beispiel durch interviews weiters anforderungsdefinition"
"data9_1_07.txt";"anforderunganalyse (anforderungsspezifikation) planungsphase -> lastenheft beschreibung repräsentation verhandlung"
"data9_1_08.txt";"geschäftsprozess ermitteln - wie ist der stand der dinge requirements engineering -> systemanforderung festlegen -> soll widerspruchsfrei und eindeutig sein system-sezifiaktion implementierung: erstellung des systems test: test des systems -> fehlererkennung und ausbesserungsphase chain management: einführung des systems in reale bedingungen und test in folgendem betrieb"
"data9_1_09.txt";"sehen ob es alternativen gibt ist es ein risiko ist es personell machbar ist es durchführbar kosten / zeit anforderungsanalyse -> requirements engineering ergebnis = spezifikation (pflichtenheft) in planungsphase lastenheft welches in der definitionsphase zum pflichtenheft wird. spezifikation soll fehler- und widerspruchs- frei sein, grundlage für systementwicklung"
"data9_1_10.txt";"anforderungsdefinition: verbale beschreibung der basisanforderungen anforderungskontext anforderungsmodell"
"data9_1_11.txt";"systematische vollständige erfassung aller anforderungen in dem kontext in dem sie anfällt -> ohne kontext sinnlos strukturieren spezifizieren repräsentieren -> darstellung (grafisch text) probleme: unterschiedlicher wissensstand und prioritäten der mitarbeiter unterschiedlich -> verhandlung notwendig"
"data9_1_12.txt";"anforderungsanalyse. gewinnung und aufzeichnung der anforderungen an ein zu erstellendes system festsetzung der organisatorischen anforderungen marktübersicht einholen - vorauswahl - bewertung - vertragsverhandlungen"
"data9_1_13.txt";"zuerst müssen die ziele der entwicklung definiert sein, um feststellen zu können welche komponenten das softwaresystem benötigen wird. dabei wird zum beispiel der geschäftsprozess (beziehungsweise die prozesse) in der personalverwaltung analysiert. danach kann man ermitteln welche module benötigt werden."
"data9_1_14.txt";"spezifikation ist die abbildung von anforderungen unter jeweils aktuellen datenbestand. präsentation, spezifikation wird kommuniziert. es wird durch mittel formate (text, graphisch) oder unformate mittel präsentiert. verhandlung beschreibung der unterschiedlichen sichten auf der selben betrachtungsebene zur kommunikation. verhandlung: verschiedene ansicht an personen verschiedene ansichten an teilfragen ziel ist zur erstellung eine der alle beteiligten verstanden und gut verstehbare systementwicklung."
"data9_2_15.txt";"schritte anforderungsanalyse spezifikation: anforderungen müssen klar definiert werden repräsentation: spezifikation muss kommuniziert werden verhandlung: verhandlung -> unterschiedliche personen haben unterschiedliche ansichten und vorwissen ziel verhandlung: einheitliche klare anforderung definieren die für alle beteiligten akzeptiert und verstanden werden."
"data9_2_16.txt";"vollständige gewinnung und aufzeichnung der anforderungen an ein zu entwickelndes system -> anforderungsspezifikation: sollte fehler- / widerspruchsfrei, verständlich und grundlage für das zu entwickelnde system sein, im laufe der entwicklung sollte aus unvollständigen beschreibungen eine konsistente, korrekte, vollständige spezifikation erstellt werden präsentation: kommunikation der spezifikation durch formale (grafik, modelle) oder informale (text) beschreibungsmittel verhandlung: verschiedene personen haben unterschiedliche ansichten an ein system -> unterschiedliche interessen -> unterschiedliche grade der übereinstimmung -> spezifikation sollte von allen akzeptiert sein"
"data9_2_17.txt";"requirement engineering - anforderungsanalyse es wird versucht alle relevanten anforderungen an ein is-system zu gewinnen und aufzuzeichnen. die aufzeichnung all dieser anforderungen führt zur anforderungsspezifikation. ziel ist verständlich und widerspruchsfrei dabei ist es wichtig spezifikationen aufzuzeichnen, und zwar alle anforderungen mit dem jetzigen stand des wissens präsentieren diese daten müssen auch repräsentiert werden daher verbale und grafische aufzeichnung verhandlung wird mit unterschiedlichen beteiligten besprochen -> management-ebene mitarbeiter und anwender programmierer - entwickler"
"data9_2_18.txt";"spezifikation: konkrete abbildung der anforderung gemäß jeweils aktuellen kenntnisständen repräsentation: spezifikation muss kommuniziert werden; formelle oder informelle beschreibungsmittel verhandlung: unterschiedlich beteiligte personen bezogen auf vorwissen und interesse"
"data9_3_19.txt";"anforderungsanalyse beinhaltet die aufzeichnung der geschäftsprozesse; sollte möglichst genau sein, fehlerfrei, widerspruchsfrei; außerdem verständlich; beinhaltet im wesentlichen die an das system gestellten anforderungen; -> was soll das system können. ergebnis der anforderungsanalyse = anforderungsspezifikation wichtig: kommunikation, präsentation"
"data9_3_20.txt";"in der ersten planungsphase wird ein lastenheft erstellt dieses lastenheft soll die wesentlichsten fachlichen anforderungen enthalten wie die wesentlichsten systemeigenschaften. das lastenheft hat einen sehr hohen abstraktionsgrad und wird deshalb in der definitionsphase zum pflichtenheft verfeinert. das ergebnis des requirement engineering ist die anforderungsspezifikation, die widerspruchs- und fehlerfrei, klar und präzise sowie verständlich sein soll. sie ist basis für die weitere systementwicklung. wichtig ist dass ein konsens aller beteiligten gefunden wird und dass jedem klar  ist, worum es geht es gibt verschiedene sichten. daten soll zum beispiel mit EP-modell funktionen zum beispiel mit klassendiagramm dynamik zum beispiel mit ??? dargestellt werden"
"data9_3_21.txt";"ein wichtiger schritt ist die spezifikation von anforderungen. zunächst enthält diese spezifikation noch die basisanforderungen und wird später schritt für schritt verfeinert. der nächste schritt ist die präsentation, die textuell und grpahisch erfolgt und mittels unterschiedlicher modelle dargestellt wird. außerdem müssen verhandlungen geführt werden, da die beteiligten meistens unterschiedliche interessen und wissen haben. das ergebnis der anforderungsanalyse ist die anforderungsspezifikation, die vollständig, verständlich und fehlerfrei sein soll."
"data9_3_22.txt";"die anforderungsanalyse hat die aufgabe, die anforderungen an ein system zu gewinnen und zu analysieren. das ergebnis sind anforderungsspezifikationen durch die das genaue anforderungsprofil an ein system beschrieben wird. diese spezifikationen müssen repräsentiert werden. hierbei helfen formale und informale methoden, zum beispiel graphiken und texte. da bei einer is-entwicklung mehrere personen mit unterschiedlichen interessen und prioritäten beteiligt sind, muß in einem dritten schritt über die anforderungsspezifikationen verhandelt werden, mit dem ziel ein für alle personen akzeptables ergebnis zu erreichen."
"data9_3_23.txt";"beim re (= requirement engineering), das gleich nach der planungsphase stattfindet, werden die anforderungen an das zu erstellende is gestellt. es stehen hierfür drei modelle zur verfügung: zielmodell (-> managerebene) -> was ist / sind ziele / subziele des is szenariomodelle (-> abbildung aller möglichen geschäftsvorfälle) lösungsmodell (für programmierer) ziel ist eine möglichst widerspruchsfreie aufgabenmodelle: regulierungsspezifikation"
"data9_3_24.txt";"die hauptaufgaben bei der anforderungsanalyse sind: spezifizieren: man erstellt die spezifikation der aktuelle wissensstand repräsentieren: man kommuniziert die spezifikation verhandeln: man geht sicher, daß alle beteiligten damit einverstanden sind; probleme: da unterschiedlicher wissensstand, unterschiedliche interessen"
"data9_3_25.txt";"anforderungsdefinition anforderungsdefinition - es sollen die anforderungen definiert werden - was soll das system machen können. anforderungsspezifikation anforderungsspezifikation - formale notation der anforderungen unter berücksichtigung verschiedener sichten möglichst genau, verständlich. softwarespezifikation software spezifikation"
"data9_3_26.txt";"requirements engineering -> gewinnung und aufzeichnung der anforderungen an ein zu erstellendes syste ergebnis: anforderungsspezifikation ziel: fehler- und widerspruchsfrei voraussetzung für systemgestaltung fehler- und widerspruchsfreie darstellung der anforderungen enthält mehrere anforderungsmodelle zielmodell szenario anforderungsmodell zuerst definition schritt 1: spezifikation korrekte abbildung des gesamtsystems von anfangs unvollständige beschreibung zu vollständigen, korrekten spezifikation schritt 2: kommunikation spezifikation muß kommuniziert werden möglichkeit der darstellung durch formale und informale beschreibungsmittel darstellung unterschiedlicher sichten schritt 3: verhandlung unterschiedlich beteiligte personen haben unterschiedliche ansichten und unterschiedlichen grad der übereinstimmung ziel: erstellen einer von allen benutzern akzeptierten, gut verständlichen systemspezifikation subprozesse: anforderungsdefinition anforderungsspezifikation software-spezifikation "
"data9_3_27.txt";"1. definition 2. spezifizierung 3. repräsentierung / präsentation 4. verhandlung endergebnis: lastenheft => detaillierter ist pflichtenheft"
"data9_3_28.txt";"Anforderunganalyse: 1. was wird vom system erwartet planungsphase -> lastenheft ist das was erwartet wird möglich (technisch) in definitionsphase -> pflichtenheft finanziell möglich welche alternativen gibt es, um das geforderte zu erstellen 2. verständliche, widerspruchsfreie und fehlerfreie definition der anforderungen ergebnis anforderungsspezifikation anforderungsdefintion anforderungsspezifikation"
"data9_3_29.txt";"anforderungsdefinition: aufnahme der anforderungen (lückenlos und verständlich) ergebnis: lastenheft anforderungsspezifikation: genaue spezifizierung der anforderungen ergebnis: pflichtenheft anforderungspräsentation"
"data9_3_30.txt";"anforderungsanalyse: spezifikation, repräsenation ermittlung aller anforderungen gewinnung und aufzeichnung aller anforderungen anofrderungsspezifikationen -> ziel möglichst fehler- und widerspruchsfrei, verständlich anforderungsdefinition in funktionale und qualitätsanforderungen"
"data9_3_31.txt";"anforderungsgewinnung (kontext, umwelt, vorgaben), hauptaufgaben: definition, repräsentation, verhandlung subprozesse: anforderungsdefinition anforderungsspezifikation softwarespezifikation typen: primäre anforderungen abgeleitete anforderungen es gibt obligatorische anforderungen, anleitungen und informationen"
"data9_4_32.txt";"anforderungsdefinition(-gewinnung) daten der anforderungen müssen gewonnen werden, zunächst verbal formuliert anforderungsspezifikation - formalere darstellung der anforderungen; verständlich systemspezifikation - modelle zur darstelung der anforderungen zielmodell, szenario, lösungsmodell zur darstellung auf verschiedenen ebenen subprozesse spezifikation - anforderung muss anhand der jeweiligen kenntnisse dargestellt werden repräsentation - anforderung muss kommuniziert werden können verhandlung - alle beteiligten müssen zu einem gemeinsamen anforderungsziel kommen"
"data9_4_33.txt";"zunächst erfolgt die anforderungsdefinition: darunter versteht man eine eher noch verbal oder nicht sehr konkret formulierte aufstellung aller anforderungen, die das unternehmen hat. ziel ist es eine möglichst umfangreiche anforderungsliste vorzufinden, damit dann mit der anofrderungsspezifikation begonnen werden kann. in der definitionsphase wird das lastenheft erstellt worin man die zielbestimmungen, produkteinsatz, -funktionen, -leistungen-, übersicht, -umfeld, qualitsätsanforderungen und ergänzungen finden kann. in der anforderungsspezifikationsphase werden die anforderungen genauer ausformuliert, da sollten sie schon fehlerfrei, widerspruchsfrei sein. das lastenheft wird in dieser phase zum pflichtenheft ausgebaut und verfeinert. die letzt phase ist die software-spezifikation. da sollten die anforderungen schon so genau formuliert sein, dass eine entwicklung (programmierung) durchgeführt werden kann."
"data9_4_34.txt";"anforderungsanalyse: 1, anforderungsdefinition durch befragung der betroffenen stellen, studium von unterlagen, interviews, etc. 2, anforderungsspezifikation, diese sollte richtig, vollständig, widerspruchsfrei und mit allen betroffenen stellen abgeklärt sein, das heißt alle sind mit der textuellen formulierung einverstanden. 3, zuletzt darstellung in mehr formalisierter form für den nächsten schritt der modellierung"
"data9_4_37.txt";"anforderungsanalyse -> requirement engineering 1. schritt = anforderungsdefinition 2. schritt = anforderungsspezifikation - formalere, genauere anforderungen 3. schritt = softwarespezifikation - anforderungen an design und implementierung in der anforderunganalyse geht es um eine möglichst vollständige auflistung der aller anforderungen ergebnis = anforderungsspezifikation detaillierte vollständige formale beschreibung aller anforderungen das lastenheft = erster entwurf der planungsphase und wird in der definitionsphase zum pflichtenheft verfeinert. überlegungen bezüglich art der anforderungen funktionale (welche funktionen) qualitätsanforderungen (wartung, bedienbarkeit) sonstige (zeit, budget)"
"data9_4_38.txt";"anforderungsanalyse anforderungsdefinition erstellen abstrakte problemstellung (hier erst anforderungsgewinnung) anforderungsspezifikation erstellen spezifischer als definition, von verbaler, abstrakter ebene auf technische umsetzungsebene software-spezifikation erstellen anhand klarer anforderungen wie abstraktes software-modell welcher grundlage für is sein soll"
"data9_4_39.txt";"anforderungsgewinnung (requirements elicitation) durch emprische verfahren (zum beispiel befragung, beobachtung, interviews, analyse von datenmaterial) spezifikation vollständige erfassung aller anforderungen an ein is funktionale anforderungen zum beispiel features wie lohn- und geldverrechnung nicht funktionale anforderungen (qualitative zum beispiel stabilität, wartbarkeit, laufzeiteffizienz) nach jeweiligem kenntnisstand im laufe der etnwicklung spezifikation verfeinern, vervollständigen anforderung sind nur im kontext sinnvoll repräsentation die spezifikation muss kommuniziert werden dazu müssen die betrachtungsgegenstände gegebenenfalls aus unterschiedlichen sichten dargestellt werden verhandlung beteiligte personen besitzen unterschiedliche vorstellungen, vorkenntnisse und präferenzen ziel der verhandlung soll eine für alle beteiligten personen akzeptierbare und verständliche systemspezifikation sein planungsphase -> ergebnis: lastenheft; definitionsphase: verfeinerung des lastenheft zu pflichtenheft subprozesse anforderungsdefinition -> verbal anforderungsspezifikation -> formaler software-spezifikation -> grundlage für systementwicklung, sehr technisch"
"data9_4_40.txt";"anforderungsanalyse ist korrekte und vollständige aufzeichnung der vom system geforderten anforderungen - zile = korrekte widerspruchsfreie abbildung (spezifikation) hauptaufgabe: 1.) anforderung spezifikation (gewinnung der vollständigen anforderung) 2.) repräsentation (darstellung in geeigneter form formal, informal) 3.) verhandlung: verhandlung: verschiedene personen haben unterschiedliche vorkenntnisse und interessen ziel der verhandlung ist es von allen ein akzeptiertes und allgemein verständliches modeel zu erhalten subprozesse: 1.) anforderungsdefinition: verbale beschreibung 2.) anforderungsspezifikation: formal beschreibung softwarespezifikation: für entwickler (implementier nahe)"
"data9_4_41.txt";"hauptaufgaben => anforderungen klar und widerspruchsfrei zu definieren spezifikation => einholen der anforderungen im glboalen sinne repräsentation => aufbereitung und kommunizieren der anforderungen für management mitarbeiter entwickler verhandlung => detailiertes ausarbeiten eines ergebnisses  subprozesse der spezifikation anforderungsdefinition: genaue definition der anforderungen in verschiedenen abteilungen, prozessen und erwartete ergebnisse anforderungsspezifikation softwarespezifikation  arten von anforderungen: funktionale: welche funktionen und prozesse werden benötigt und erwartet qualitative: welches qualitätsniveau wird erwartet => kostenfaktor (programmiersprache, erweiterbarkeit, ...) zusätzliche: zeitliche, budgetäre, schnittstellen, ..."
"data9_4_42.txt";"anforderungsdefinition: welche anforderungen anforderungsspezifikation: notation der anforderungen in eine für die zielgruppe verständliche sprache softwarespezifikation: beschreibung der software-anforderungen programmierorientiert vollständige, widerspruchsfreie nur sinnvoll, wenn in einen kontext eingebettet"
"data9_4_43.txt";"anforderungsanalyse: requirement engineering: hauptaufgaben: 1) spezifikation: spezifizieren, genau die anforderungen; was muß / sollte mein personal - verwaltungssystem können 2) repräsentation: formal und informale betrachtungsweise; auf verschiedene sichten des beobachtungsgegenstandes 3) verhandlung: kommunikation mit beteiligten -> unterschiedliche perspektiven, interesse, wissen, anforderungen subprozesse des requirement engineering: 1) anforderungsdefinition 2) anforderungsspezifikation 3) software spezifikation es gibt verschiedene arten von anforderungen: funktionale und qualitätsanforderungen; lastenheft -> dient in der zum pflichtenheft: lastenheft besteht aus: 1) zielbestimmung   5) produktfunktion 2) produkteinsatz   6) produktdaten 3) produktleistung   7) qualitätsanforderung 4) produktumgebung   8) ergänzungen anofrderungstypen (primär, abgeleitet) einhaltung der anforderungen prioritäten (kosten, zeit, etc.)"
"data9_4_44.txt";"wichtige hauptschritte: spezifikation: bewertung der anforderungen an das system (qualität / quantität, funktionen, etc.). welche grundlegenden funktionen sind erforderlich. welche schnittstellen, etc. grundlegende entscheidungen über hardware / software, etc. sind zu treffen. repräsentation: vermittlung der anforderungen (spezifikationen an verschiedene unternehmensbereiche. darstellung der funktionen, etc. (möglichst transparent). verhandlung: ziel: ein system, das von allen beteiligten akzeptiert wird. eventuell müssen kompromisse eingegangen werden. subprozesse anforderungsdefinition: überblicksmäßige vorstellung der funktionen, umwelt, leistungen, daten, qualitätsanforderungen des systems. sollte transparent und leicht verständlich sein. anforderungsspezifikation: detailliertere darstellung der spezifikationen des systems (genaue funktionen, etc.) => auch für entwickler softwarespezifikation: vollständige darstellung der benötigten funktionen, darstellung der verschiedenen software-schichten, etc."
"data9_4_45.txt";"die anforderungsanalyse (requirements engineering) besteht grob gesagt aus drei zusammenhängenden teilen: der anforderungsdefinition: hier wird in verbaler sprache festgelegt, welche ziele ein system haben soll, was zunächst nur sehr abstrakt möglich ist (=> lastenheft) der anforderungsspezifikation: hier wird die definition  aus dem lastenheft verfeinert und zum pflichtenheft, das bereits alle programmiereigenschaften beinhaltet, weiterentwicklung repräsentation / spezifikation / verhandlung und der software-spezifikation die anforderungsspezifikation wird dann in technisches vokabular übergeleitet, um für techniker verständlich eine implementierung zu ermöglichen."
"data9_4_47.txt";"zuerst müssen alle nötigen anforderungen gesammelt werden, diese müssen als ergebnis eine fehlerlose und widerspruchsfreie spezifikation ergeben. die anforderungne müssen eben definiert werden und danach spezialisiert. dabei muss man aber darauf auchten, dass diese auch allgemein verständlich ist und von jedem akzeptiert wird, denn es sind viele verschiedene personen mit verschiedenen anforderungsvorstellungen, wissen, interesse, etc. beteiligt. durch verhandlungen muss man für die anforderung eben einen konsens finden, damit diese letztendlich auch von allen akzeptiert und verstanden wird. die anforderung soll auch dementsprechend repräsentiert werden, durch formale oder informale darstellung. bei der anforderungsanalyse sind auch noch zu beachten -> die prioritäten und zwar in bezug auf zeit (ist es eine langfristige anforderung), in bezug auf das budget (monetäre rahmen) und auch auf die quelle (von wem diese anforderung kommt, es macht einen unterschied ob sie vom lagerarbeiter oder vom geschäftsführer kommt)"
"data9_4_48.txt";"anforderungsdefinition: vollständige gewinnung sämtlicher anforderungen an ein system -> anforderungstype -> primär -> abgeleitet meist auf abstrakter ebene. einhaltung der anforderungen -> obligatorisch -> kann-bestimmung: bis zu einem bestimmten grad einzuhalten -> information art der anforderung -> produkt-bezogen, projektbezogen priorität anforderungsspezifikation: verbindung zum entwickler. meist werden modelle zur darstellung einesetzt. repräsentation: darstellung der anforderungen. schriftliche form und modelle verhandlung: einigung auf eine anforderungsanalyse software-spezifikation: modelle für den entwickler, systementwurf, implementierung"
"data9_4_49.txt";"anforderungsdefinition anforderungsspezifikation softwarespezifikation: prozesse bei anforderunganalyse sie müsen zerst spezifikationen ermitteln. die ergebnisse von anforderungsanalyse ist spezifikationen. dann diese spezifikationen kommunizieren. darstellung von anforderungen zu alle beteiligten repräsentation sie müssen ermgölichen, die alle beteiligten diese spezifikationen verstanden und angenommen haben -> verhandlung = agreement"
